<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Rigs of Rods: source/main/physics/BeamForcesEuler.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="rorlogo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rigs of Rods
   
   </div>
   <div id="projectbrief">Soft-body Physics Simulation</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">source/main/physics/BeamForcesEuler.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_beam_forces_euler_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">This source file is part of Rigs of Rods</span>
<a name="l00003"></a>00003 <span class="comment">Copyright 2005-2012 Pierre-Michel Ricordel</span>
<a name="l00004"></a>00004 <span class="comment">Copyright 2007-2012 Thomas Fischer</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">For more information, see http://www.rigsofrods.com/</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">Rigs of Rods is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment">it under the terms of the GNU General Public License version 3, as</span>
<a name="l00010"></a>00010 <span class="comment">published by the Free Software Foundation.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">Rigs of Rods is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">along with Rigs of Rods.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment">*/</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="_ro_r_prerequisites_8h.html">RoRPrerequisites.h</a>&quot;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="_aero_engine_8h.html">AeroEngine.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="_air_brake_8h.html">AirBrake.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="_airfoil_8h.html">Airfoil.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="_application_8h.html" title="Central object manager and communications hub.">Application.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="_approx_math_8h.html">ApproxMath.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="_beam_8h.html">Beam.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="_beam_engine_8h.html">BeamEngine.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="_beam_factory_8h.html">BeamFactory.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="_beam_stats_8h.html">BeamStats.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="_buoyance_8h.html">Buoyance.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="_cmd_key_inertia_8h.html">CmdKeyInertia.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="_collisions_8h.html">Collisions.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="_differentials_8h.html">Differentials.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="_dust_pool_8h.html">DustPool.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="_flex_airfoil_8h.html">FlexAirfoil.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="_input_engine_8h.html" title="Input logic.">InputEngine.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="_replay_8h.html">Replay.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="_screw_prop_8h.html">ScrewProp.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="_sound_script_manager_8h.html">SoundScriptManager.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="_water_8h.html">Water.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="_terrain_manager_8h.html">TerrainManager.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="_thread_pool_8h.html">ThreadPool.h</a>&quot;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="_beam_forces_euler_8cpp.html#a58ca2a02ea30efaf8e5b650034e61d04">00045</a> <span class="preprocessor">#define BEAMS_INTER_TRUCK_PARALLEL 1</span>
<a name="l00046"></a><a class="code" href="_beam_forces_euler_8cpp.html#ac003d9f1f997d0967b3f17eaf00672bb">00046</a> <span class="preprocessor"></span><span class="preprocessor">#define BEAMS_INTRA_TRUCK_PARALLEL 0</span>
<a name="l00047"></a><a class="code" href="_beam_forces_euler_8cpp.html#ac19c95b442746cc3dc2c1c417e42a2c8">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define NODES_INTER_TRUCK_PARALLEL 1</span>
<a name="l00048"></a><a class="code" href="_beam_forces_euler_8cpp.html#a2029edf6a3268e3adde0180377613a4f">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define NODES_INTRA_TRUCK_PARALLEL 0</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="keyword">using namespace </span>Ogre;
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="class_beam.html#a6c440445640a12a8bf52fa0127365708">00052</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a6c440445640a12a8bf52fa0127365708">Beam::calcForcesEulerCompute</a>(<span class="keywordtype">int</span> doUpdate_int, Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps)
<a name="l00053"></a>00053 {
<a name="l00054"></a>00054     <span class="keywordtype">bool</span> doUpdate = (doUpdate_int != 0);
<a name="l00055"></a>00055     calcTruckEngine(doUpdate, dt);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057     <span class="comment">// calc</span>
<a name="l00058"></a>00058     calcBeams(doUpdate, dt, step, maxsteps);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060     <span class="comment">// not related to physics</span>
<a name="l00061"></a>00061     calcAnimatedProps(doUpdate, dt);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063     calcMouse();
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     calcScrewProp(doUpdate);
<a name="l00066"></a>00066     calcWing();
<a name="l00067"></a>00067     calcFuseDrag();
<a name="l00068"></a>00068     calcAirBrakes();
<a name="l00069"></a>00069     calcBuoyance(doUpdate, dt, step, maxsteps);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     calcAxles(doUpdate, dt);
<a name="l00072"></a>00072     calcWheels(doUpdate, dt, step, maxsteps);
<a name="l00073"></a>00073     calcShocks(doUpdate, dt);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     calcHydros(doUpdate, dt);
<a name="l00076"></a>00076     calcCommands(doUpdate, dt);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="comment">// integration, most likely this needs to be done after all the</span>
<a name="l00079"></a>00079     <span class="comment">// forces have been calculated other wise, forces might linger</span>
<a name="l00080"></a>00080     calcNodes_(doUpdate, dt, step, maxsteps);
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">//This has to be done after the nodes</span>
<a name="l00083"></a>00083     calcTurboProp(doUpdate, dt);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     calcReplay(doUpdate, dt);
<a name="l00086"></a>00086     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_WholeTruckCalc);
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a><a class="code" href="class_beam.html#ab6c56c2b8fd9f592a487b8a788ca9d11">00089</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#ab6c56c2b8fd9f592a487b8a788ca9d11" title="calc forces euler division">Beam::calcTruckEngine</a>(<span class="keywordtype">bool</span> doUpdate, Real dt)
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_TruckEngine);
<a name="l00092"></a>00092     <span class="comment">//engine callback</span>
<a name="l00093"></a>00093     <span class="keywordflow">if</span> (engine)
<a name="l00094"></a>00094     {
<a name="l00095"></a>00095         engine-&gt;update(dt, doUpdate);
<a name="l00096"></a>00096     }
<a name="l00097"></a>00097     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_TruckEngine);
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099     <span class="comment">//if (doUpdate) mWindow-&gt;setDebugText(engine-&gt;status);</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="keywordtype">void</span> <a class="code" href="class_beam.html#aec1d802b1efee85ebaa13a6e9dccf036">Beam::calcBeams</a>(<span class="keywordtype">bool</span> doUpdate, Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103 <span class="preprocessor">#if BEAMS_INTER_TRUCK_PARALLEL</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#if !BEAMS_INTRA_TRUCK_PARALLEL</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span>    calcBeams(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l00106"></a>00106 <span class="preprocessor">#else</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (free_beam &lt; 100)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109         calcBeams(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l00110"></a>00110     } <span class="keywordflow">else</span>
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112         runThreadTask(<span class="keyword">this</span>, THREAD_BEAMS, <span class="keyword">true</span>);
<a name="l00113"></a>00113     }
<a name="l00114"></a>00114 <span class="preprocessor">#endif</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (doUpdate)
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117         <span class="comment">//just call this once per frame to avoid performance impact</span>
<a name="l00118"></a>00118         hookToggle(-2, <a class="code" href="_beam_data_8h.html#a59960ab4d65cd4767a327f24976651cba458a88d526512a61401a9dafcc61b53b">HOOK_LOCK</a>, -1);
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120 <span class="preprocessor">#endif</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span>
<a name="l00122"></a>00122     <span class="comment">//auto locks (scan just once per frame, need to use a timer(truck-based) to get</span>
<a name="l00123"></a>00123     <span class="keywordflow">for</span> (std::vector &lt;hook_t&gt;::iterator it = hooks.begin(); it!=hooks.end(); it++)
<a name="l00124"></a>00124     {
<a name="l00125"></a>00125         <span class="comment">//we need to do this here to avoid countdown speedup by triggers</span>
<a name="l00126"></a>00126         it-&gt;timer -= dt;
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (it-&gt;timer &lt; 0)
<a name="l00128"></a>00128         {
<a name="l00129"></a>00129             it-&gt;timer = 0.0f;
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a><a class="code" href="class_beam.html#ad0cf39a3ca17cad8a038d8984c6ad11f">00134</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#ad0cf39a3ca17cad8a038d8984c6ad11f">Beam::calcAnimatedProps</a>(<span class="keywordtype">bool</span> doUpdate, Real dt)
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_AnimatedProps);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="comment">//animate props</span>
<a name="l00139"></a>00139     <span class="comment">// TODO: only calculate animated props every frame and not in the core routine</span>
<a name="l00140"></a>00140     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> propi=0; propi&lt;free_prop; propi++)
<a name="l00141"></a>00141     {
<a name="l00142"></a>00142         <span class="keywordtype">int</span> animnum=0;
<a name="l00143"></a>00143         <span class="keywordtype">float</span> rx = 0.0f;
<a name="l00144"></a>00144         <span class="keywordtype">float</span> ry = 0.0f;
<a name="l00145"></a>00145         <span class="keywordtype">float</span> rz = 0.0f;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147         <span class="keywordflow">while</span> (props[propi].animFlags[animnum])
<a name="l00148"></a>00148         {
<a name="l00149"></a>00149             <span class="keywordflow">if</span> (props[propi].animFlags[animnum])
<a name="l00150"></a>00150             {
<a name="l00151"></a>00151                 <span class="keywordtype">float</span> cstate = 0.0f;
<a name="l00152"></a>00152                 <span class="keywordtype">int</span> div = 0.0f;
<a name="l00153"></a>00153                 <span class="keywordtype">int</span> flagstate = props[propi].animFlags[animnum];
<a name="l00154"></a>00154                 <span class="keywordtype">float</span> animOpt1 = props[propi].animOpt1[animnum];
<a name="l00155"></a>00155                 <span class="keywordtype">float</span> animOpt2 = props[propi].animOpt2[animnum];
<a name="l00156"></a>00156                 <span class="keywordtype">float</span> animOpt3 = props[propi].animOpt3[animnum];
<a name="l00157"></a>00157 
<a name="l00158"></a>00158                 calcAnimators(flagstate, cstate, div, dt, animOpt1, animOpt2, animOpt3);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160                 <span class="comment">// key triggered animations</span>
<a name="l00161"></a>00161                 <span class="keywordflow">if</span> ((props[propi].animFlags[animnum] &amp; <a class="code" href="_beam_data_8h.html#aac34dfe6c6b73b43a4656c9dce041034a4b71bd492d316cd619203ac8f43a6925">ANIM_FLAG_EVENT</a>) &amp;&amp; props[propi].animKey[animnum] != -1)
<a name="l00162"></a>00162                 {
<a name="l00163"></a>00163                     <span class="keywordflow">if</span> (<a class="code" href="class_ro_r_1_1_application.html#a608003a20ef939a79437a9da8fa76307">RoR::Application::GetInputEngine</a>()-&gt;getEventValue(props[propi].animKey[animnum]))
<a name="l00164"></a>00164                     {
<a name="l00165"></a>00165                         <span class="comment">// keystatelock is disabled then set cstate</span>
<a name="l00166"></a>00166                         <span class="keywordflow">if</span> (props[propi].animKeyState[animnum] == -1.0f)
<a name="l00167"></a>00167                         {
<a name="l00168"></a>00168                             cstate += <a class="code" href="class_ro_r_1_1_application.html#a608003a20ef939a79437a9da8fa76307">RoR::Application::GetInputEngine</a>()-&gt;<a class="code" href="class_input_engine.html#a251be92f16fe445542e240fc121354d8">getEventValue</a>(props[propi].animKey[animnum]);
<a name="l00169"></a>00169                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!props[propi].animKeyState[animnum])
<a name="l00170"></a>00170                         {
<a name="l00171"></a>00171                             <span class="comment">// a key was pressed and a toggle was done already, so bypass</span>
<a name="l00172"></a>00172                             <span class="comment">//toggle now</span>
<a name="l00173"></a>00173                             <span class="keywordflow">if</span> (!props[propi].lastanimKS[animnum])
<a name="l00174"></a>00174                             {
<a name="l00175"></a>00175                                 props[propi].lastanimKS[animnum] = 1.0f;
<a name="l00176"></a>00176                                 <span class="comment">// use animkey as bool to determine keypress / release state of inputengine</span>
<a name="l00177"></a>00177                                 props[propi].animKeyState[animnum] = 1.0f;
<a name="l00178"></a>00178                             }
<a name="l00179"></a>00179                             <span class="keywordflow">else</span>
<a name="l00180"></a>00180                             {
<a name="l00181"></a>00181                                 props[propi].lastanimKS[animnum] = 0.0f;
<a name="l00182"></a>00182                                 <span class="comment">// use animkey as bool to determine keypress / release state of inputengine</span>
<a name="l00183"></a>00183                                 props[propi].animKeyState[animnum] = 1.0f;
<a name="l00184"></a>00184                             }
<a name="l00185"></a>00185                         } <span class="keywordflow">else</span>
<a name="l00186"></a>00186                         {
<a name="l00187"></a>00187                             <span class="comment">// bypas mode, get the last set position and set it</span>
<a name="l00188"></a>00188                             cstate +=props[propi].lastanimKS[animnum];
<a name="l00189"></a>00189                         }
<a name="l00190"></a>00190                     } <span class="keywordflow">else</span>
<a name="l00191"></a>00191                     {
<a name="l00192"></a>00192                         <span class="comment">// keyevent exists and keylock is enabled but the key isnt pressed right now = get lastanimkeystatus for cstate and reset keypressed bool animkey</span>
<a name="l00193"></a>00193                         <span class="keywordflow">if</span> (props[propi].animKeyState[animnum] != -1.0f)
<a name="l00194"></a>00194                         {
<a name="l00195"></a>00195                             cstate +=props[propi].lastanimKS[animnum];
<a name="l00196"></a>00196                             props[propi].animKeyState[animnum] = 0.0f;
<a name="l00197"></a>00197                         }
<a name="l00198"></a>00198                     }
<a name="l00199"></a>00199                 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201                 <span class="comment">//propanimation placed here to avoid interference with existing hydros(cstate) and permanent prop animation</span>
<a name="l00202"></a>00202                 <span class="comment">//truck steering</span>
<a name="l00203"></a>00203                 <span class="keywordflow">if</span> (props[propi].animFlags[animnum] &amp; <a class="code" href="_beam_data_8h.html#aac34dfe6c6b73b43a4656c9dce041034ae10c35bb9f6df9f04aefd349f448e23a">ANIM_FLAG_STEERING</a>) cstate += hydrodirstate;
<a name="l00204"></a>00204                 <span class="comment">//aileron</span>
<a name="l00205"></a>00205                 <span class="keywordflow">if</span> (props[propi].animFlags[animnum] &amp; <a class="code" href="_beam_data_8h.html#aac34dfe6c6b73b43a4656c9dce041034abefc5c30695c75219b96843a07ee6e9e">ANIM_FLAG_AILERONS</a>) cstate += hydroaileronstate;
<a name="l00206"></a>00206                 <span class="comment">//elevator</span>
<a name="l00207"></a>00207                 <span class="keywordflow">if</span> (props[propi].animFlags[animnum] &amp; <a class="code" href="_beam_data_8h.html#aac34dfe6c6b73b43a4656c9dce041034af939efdaf0ca38bfe6c6d3f9b52b3ee1">ANIM_FLAG_ELEVATORS</a>) cstate += hydroelevatorstate;
<a name="l00208"></a>00208                 <span class="comment">//rudder</span>
<a name="l00209"></a>00209                 <span class="keywordflow">if</span> (props[propi].animFlags[animnum] &amp; <a class="code" href="_beam_data_8h.html#aac34dfe6c6b73b43a4656c9dce041034ae8c76242bcc8ab8c495f42f9e105269b">ANIM_FLAG_ARUDDER</a>) cstate += hydrorudderstate;
<a name="l00210"></a>00210                 <span class="comment">//permanent</span>
<a name="l00211"></a>00211                 <span class="keywordflow">if</span> (props[propi].animFlags[animnum] &amp; <a class="code" href="_beam_data_8h.html#aac34dfe6c6b73b43a4656c9dce041034ac2569b3f959e23fc1d891e58551f1047">ANIM_FLAG_PERMANENT</a>) cstate += 1.0f;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213                 cstate *= props[propi].animratio[animnum];
<a name="l00214"></a>00214 
<a name="l00215"></a>00215                 <span class="comment">// autoanimate noflip_bouncer</span>
<a name="l00216"></a>00216                 <span class="keywordflow">if</span> (props[propi].animOpt5[animnum]) cstate *= (props[propi].animOpt5[animnum]);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218                 <span class="comment">//rotate prop</span>
<a name="l00219"></a>00219                 <span class="keywordflow">if</span> ((props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba8bf721601f7bb07158c7816238144fac">ANIM_MODE_ROTA_X</a>) || (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebbac30a915cce9cd446e24b96b6e84d1c5c">ANIM_MODE_ROTA_Y</a>) || (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba09c61b9b6cf0f549a6d2e8c4aa470319">ANIM_MODE_ROTA_Z</a>))
<a name="l00220"></a>00220                 {
<a name="l00221"></a>00221                     <span class="keywordtype">float</span> limiter = 0.0f;
<a name="l00222"></a>00222                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebbadd2289aa1cf5d5f60c9cac9e9ea6c3cb">ANIM_MODE_AUTOANIMATE</a>)
<a name="l00223"></a>00223                     {
<a name="l00224"></a>00224                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_ROTA_X)
<a name="l00225"></a>00225                         {
<a name="l00226"></a>00226                             props[propi].rot = props[propi].rot * (Quaternion(Degree(0), Vector3::UNIT_Z) * Quaternion(Degree(0), Vector3::UNIT_Y) * Quaternion(Degree(cstate), Vector3::UNIT_X));
<a name="l00227"></a>00227                             props[propi].rotaX += cstate;
<a name="l00228"></a>00228                             limiter = props[propi].rotaX;
<a name="l00229"></a>00229                         }
<a name="l00230"></a>00230                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebbac30a915cce9cd446e24b96b6e84d1c5c">ANIM_MODE_ROTA_Y</a>)
<a name="l00231"></a>00231                         {
<a name="l00232"></a>00232                             props[propi].rot = props[propi].rot * (Quaternion(Degree(0), Vector3::UNIT_Z) * Quaternion(Degree(cstate), Vector3::UNIT_Y) * Quaternion(Degree(0), Vector3::UNIT_X));
<a name="l00233"></a>00233                             props[propi].rotaY += cstate;
<a name="l00234"></a>00234                             limiter = props[propi].rotaY;
<a name="l00235"></a>00235                         }
<a name="l00236"></a>00236                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_ROTA_Z)
<a name="l00237"></a>00237                         {
<a name="l00238"></a>00238                             props[propi].rot = props[propi].rot * (Quaternion(Degree(cstate), Vector3::UNIT_Z) * Quaternion(Degree(0), Vector3::UNIT_Y) * Quaternion(Degree(0), Vector3::UNIT_X));
<a name="l00239"></a>00239                             props[propi].rotaZ += cstate;
<a name="l00240"></a>00240                             limiter = props[propi].rotaZ;
<a name="l00241"></a>00241                         }
<a name="l00242"></a>00242                     } <span class="keywordflow">else</span>
<a name="l00243"></a>00243                     {
<a name="l00244"></a>00244                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_ROTA_X) rx += cstate;
<a name="l00245"></a>00245                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebbac30a915cce9cd446e24b96b6e84d1c5c">ANIM_MODE_ROTA_Y</a>) ry += cstate;
<a name="l00246"></a>00246                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_ROTA_Z) rz += cstate;
<a name="l00247"></a>00247                     }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249                     <span class="keywordtype">bool</span> limiterchanged = <span class="keyword">false</span>;
<a name="l00250"></a>00250                     <span class="comment">// check if a positive custom limit is set to evaluate/calc flip back</span>
<a name="l00251"></a>00251                     <span class="keywordflow">if</span> (props[propi].animOpt2[animnum] - props[propi].animOpt4[animnum])
<a name="l00252"></a>00252                     {
<a name="l00253"></a>00253                         <span class="keywordflow">if</span> (limiter &gt; props[propi].animOpt2[animnum])
<a name="l00254"></a>00254                         {
<a name="l00255"></a>00255                             <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00256"></a>00256                             {
<a name="l00257"></a>00257                                 limiter = props[propi].animOpt2[animnum];               <span class="comment">// stop at limit</span>
<a name="l00258"></a>00258                                 props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if bounce is set</span>
<a name="l00259"></a>00259                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00260"></a>00260                             } <span class="keywordflow">else</span>
<a name="l00261"></a>00261                             {
<a name="l00262"></a>00262                                 limiter = props[propi].animOpt1[animnum];               <span class="comment">// flip to other side at limit</span>
<a name="l00263"></a>00263                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00264"></a>00264                             }
<a name="l00265"></a>00265                         }
<a name="l00266"></a>00266                     } <span class="keywordflow">else</span>
<a name="l00267"></a>00267                     {                                                                   <span class="comment">// no custom limit set, use 360�</span>
<a name="l00268"></a>00268                         <span class="keywordflow">while</span> (limiter &gt; 180.0f)
<a name="l00269"></a>00269                         {
<a name="l00270"></a>00270                             <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00271"></a>00271                             {
<a name="l00272"></a>00272                                 limiter = 180.0f;                                       <span class="comment">// stop at limit</span>
<a name="l00273"></a>00273                                 props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if bounce is set</span>
<a name="l00274"></a>00274                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00275"></a>00275                             } <span class="keywordflow">else</span>
<a name="l00276"></a>00276                             {
<a name="l00277"></a>00277                                 limiter -= 360.0f;                                      <span class="comment">// flip to other side at limit</span>
<a name="l00278"></a>00278                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00279"></a>00279                             }
<a name="l00280"></a>00280                         }
<a name="l00281"></a>00281                     }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283                     <span class="comment">// check if a negative custom limit is set to evaluate/calc flip back</span>
<a name="l00284"></a>00284                     <span class="keywordflow">if</span> (props[propi].animOpt1[animnum] - props[propi].animOpt4[animnum])
<a name="l00285"></a>00285                     {
<a name="l00286"></a>00286                         <span class="keywordflow">if</span> (limiter &lt; (props[propi].animOpt1[animnum]))
<a name="l00287"></a>00287                         {
<a name="l00288"></a>00288                             <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00289"></a>00289                             {
<a name="l00290"></a>00290                                 limiter = props[propi].animOpt1[animnum];               <span class="comment">// stop at limit</span>
<a name="l00291"></a>00291                                 props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if active</span>
<a name="l00292"></a>00292                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00293"></a>00293                             } <span class="keywordflow">else</span>
<a name="l00294"></a>00294                             {
<a name="l00295"></a>00295                                 limiter = props[propi].animOpt2[animnum];               <span class="comment">// flip to other side at limit</span>
<a name="l00296"></a>00296                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00297"></a>00297                             }
<a name="l00298"></a>00298                         }
<a name="l00299"></a>00299                     } <span class="keywordflow">else</span>                                                              <span class="comment">// no custom limit set, use 360�</span>
<a name="l00300"></a>00300                     {
<a name="l00301"></a>00301                         <span class="keywordflow">while</span> (limiter &lt; -180.0f)
<a name="l00302"></a>00302                         {
<a name="l00303"></a>00303                             <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00304"></a>00304                             {
<a name="l00305"></a>00305                                 limiter = -180.0f;                                      <span class="comment">// stop at limit</span>
<a name="l00306"></a>00306                                 props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if active</span>
<a name="l00307"></a>00307                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00308"></a>00308                             } <span class="keywordflow">else</span>
<a name="l00309"></a>00309                             {
<a name="l00310"></a>00310                                 limiter += 360.0f;                                      <span class="comment">// flip to other side at limit including overflow</span>
<a name="l00311"></a>00311                                 limiterchanged = <span class="keyword">true</span>;
<a name="l00312"></a>00312                             }
<a name="l00313"></a>00313                         }
<a name="l00314"></a>00314                     }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316                     <span class="keywordflow">if</span> (limiterchanged)
<a name="l00317"></a>00317                     {
<a name="l00318"></a>00318                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_ROTA_X) props[propi].rotaX = limiter;
<a name="l00319"></a>00319                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebbac30a915cce9cd446e24b96b6e84d1c5c">ANIM_MODE_ROTA_Y</a>) props[propi].rotaY = limiter;
<a name="l00320"></a>00320                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_ROTA_Z) props[propi].rotaZ = limiter;
<a name="l00321"></a>00321                     }
<a name="l00322"></a>00322                 }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324                 <span class="comment">//offset prop</span>
<a name="l00325"></a>00325 
<a name="l00326"></a>00326                 <span class="comment">// TODO Unused Varaible</span>
<a name="l00327"></a>00327                 <span class="comment">//float ox = props[propi].orgoffsetX;</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329                 <span class="comment">// TODO Unused Varaible</span>
<a name="l00330"></a>00330                 <span class="comment">//float oy = props[propi].orgoffsetY;</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332                 <span class="comment">// TODO Unused Varaible</span>
<a name="l00333"></a>00333                 <span class="comment">//float oz = props[propi].orgoffsetZ;</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335                 <span class="keywordflow">if</span> ((props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba341b082cc545a965a50cc9752748bae3">ANIM_MODE_OFFSET_X</a>) || (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba0ecb80b05e58f63cdc0b75e5609537be">ANIM_MODE_OFFSET_Y</a>) || (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba3fd9d2faf67ad41ee5bccf4ae081df7a">ANIM_MODE_OFFSET_Z</a>))
<a name="l00336"></a>00336                 {
<a name="l00337"></a>00337                     <span class="keywordtype">float</span> offset = 0.0f;
<a name="l00338"></a>00338                     <span class="keywordtype">float</span> autooffset = 0.0f;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_OFFSET_X) offset = props[propi].orgoffsetX;
<a name="l00341"></a>00341                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba0ecb80b05e58f63cdc0b75e5609537be">ANIM_MODE_OFFSET_Y</a>) offset = props[propi].orgoffsetY;
<a name="l00342"></a>00342                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_OFFSET_Z) offset = props[propi].orgoffsetZ;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344                     offset += cstate;
<a name="l00345"></a>00345                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebbadd2289aa1cf5d5f60c9cac9e9ea6c3cb">ANIM_MODE_AUTOANIMATE</a>)
<a name="l00346"></a>00346                     {
<a name="l00347"></a>00347                         autooffset = offset;
<a name="l00348"></a>00348                         <span class="comment">// check if a positive custom limit is set to evaluate/calc flip back</span>
<a name="l00349"></a>00349                         <span class="keywordflow">if</span> (props[propi].animOpt2[animnum] - props[propi].animOpt4[animnum])
<a name="l00350"></a>00350                         {
<a name="l00351"></a>00351                             <span class="keywordflow">if</span> (autooffset &gt; props[propi].animOpt2[animnum])
<a name="l00352"></a>00352                             {
<a name="l00353"></a>00353                                 <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00354"></a>00354                                 {
<a name="l00355"></a>00355                                     autooffset = props[propi].animOpt2[animnum];            <span class="comment">// stop at limit</span>
<a name="l00356"></a>00356                                     props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if active</span>
<a name="l00357"></a>00357                                 } <span class="keywordflow">else</span>
<a name="l00358"></a>00358                                     autooffset = props[propi].animOpt1[animnum];            <span class="comment">// flip to other side at limit</span>
<a name="l00359"></a>00359                             }
<a name="l00360"></a>00360                         } <span class="keywordflow">else</span>                                                              <span class="comment">// no custom limit set, use 10x as default</span>
<a name="l00361"></a>00361                         {
<a name="l00362"></a>00362                             <span class="keywordflow">while</span> (autooffset &gt; 10.0f)
<a name="l00363"></a>00363                             {
<a name="l00364"></a>00364                                 <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00365"></a>00365                                 {
<a name="l00366"></a>00366                                     autooffset = 10.0f;                                     <span class="comment">// stop at limit</span>
<a name="l00367"></a>00367                                     props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if bounce is set</span>
<a name="l00368"></a>00368                                 } <span class="keywordflow">else</span>
<a name="l00369"></a>00369                                     autooffset -= 20.0f;                                    <span class="comment">// flip to other side at limit including overflow</span>
<a name="l00370"></a>00370                             }
<a name="l00371"></a>00371                         }
<a name="l00372"></a>00372                         <span class="comment">// check if a negative custom limit is set to evaluate/calc flip back</span>
<a name="l00373"></a>00373                         <span class="keywordflow">if</span> (props[propi].animOpt1[animnum] - props[propi].animOpt4[animnum])
<a name="l00374"></a>00374                         {
<a name="l00375"></a>00375                             <span class="keywordflow">if</span> (autooffset &lt; (props[propi].animOpt1[animnum]))
<a name="l00376"></a>00376                             {
<a name="l00377"></a>00377                                 <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00378"></a>00378                                 {
<a name="l00379"></a>00379                                     autooffset = props[propi].animOpt1[animnum];            <span class="comment">// stop at limit</span>
<a name="l00380"></a>00380                                     props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if active</span>
<a name="l00381"></a>00381                                 } <span class="keywordflow">else</span>
<a name="l00382"></a>00382                                     autooffset = props[propi].animOpt2[animnum];            <span class="comment">// flip to other side at limit</span>
<a name="l00383"></a>00383                             }
<a name="l00384"></a>00384                         } <span class="keywordflow">else</span>                                                              <span class="comment">// no custom limit set, use -10x�</span>
<a name="l00385"></a>00385                         {
<a name="l00386"></a>00386                             <span class="keywordflow">while</span> (autooffset &lt; -10.0f)
<a name="l00387"></a>00387                             {
<a name="l00388"></a>00388                                 <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; <a class="code" href="_beam_data_8h.html#a0ed680fdb405e7195d9f14032851eebba623f30f46fef2099003bc9093956c628">ANIM_MODE_NOFLIP</a>)
<a name="l00389"></a>00389                                 {
<a name="l00390"></a>00390                                     autooffset = -10.0f;                                    <span class="comment">// stop at limit</span>
<a name="l00391"></a>00391                                     props[propi].animOpt5[animnum] *= -1.0f;                <span class="comment">// change cstate multiplier if bounce is set</span>
<a name="l00392"></a>00392                                 } <span class="keywordflow">else</span>
<a name="l00393"></a>00393                                     autooffset += 20.0f;                                    <span class="comment">// flip to other side at limit including overflow</span>
<a name="l00394"></a>00394                             }
<a name="l00395"></a>00395                         }
<a name="l00396"></a>00396                     }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_OFFSET_X)
<a name="l00399"></a>00399                     {
<a name="l00400"></a>00400                         props[propi].offsetx = offset;
<a name="l00401"></a>00401                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_AUTOANIMATE)
<a name="l00402"></a>00402                             props[propi].orgoffsetX = autooffset;
<a name="l00403"></a>00403                     }
<a name="l00404"></a>00404                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_OFFSET_Y)
<a name="l00405"></a>00405                     {
<a name="l00406"></a>00406                         props[propi].offsety = offset;
<a name="l00407"></a>00407                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_AUTOANIMATE)
<a name="l00408"></a>00408                             props[propi].orgoffsetY = autooffset;
<a name="l00409"></a>00409                     }
<a name="l00410"></a>00410                     <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_OFFSET_Z)
<a name="l00411"></a>00411                     {
<a name="l00412"></a>00412                         props[propi].offsetz = offset;
<a name="l00413"></a>00413                         <span class="keywordflow">if</span> (props[propi].animMode[animnum] &amp; ANIM_MODE_AUTOANIMATE)
<a name="l00414"></a>00414                             props[propi].orgoffsetZ = autooffset;
<a name="l00415"></a>00415                     }
<a name="l00416"></a>00416                 }
<a name="l00417"></a>00417             }
<a name="l00418"></a>00418             animnum++;
<a name="l00419"></a>00419         }
<a name="l00420"></a>00420         <span class="comment">//recalc the quaternions with final stacked rotation values ( rx, ry, rz )</span>
<a name="l00421"></a>00421         rx += props[propi].rotaX;
<a name="l00422"></a>00422         ry += props[propi].rotaY;
<a name="l00423"></a>00423         rz += props[propi].rotaZ;
<a name="l00424"></a>00424         props[propi].rot = Quaternion(Degree(rz), Vector3::UNIT_Z) * Quaternion(Degree(ry), Vector3::UNIT_Y) * Quaternion(Degree(rx), Vector3::UNIT_X);
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_AnimatedProps);
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a><a class="code" href="class_beam.html#adbb4f625d1330c987e38a4c23a4933ac">00430</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#adbb4f625d1330c987e38a4c23a4933ac">Beam::calcForceFeedBack</a>(<span class="keywordtype">bool</span> doUpdate)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432     <span class="keywordflow">if</span> (state==<a class="code" href="_beam_data_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a84b328a7ebdea4c8c4ed62e035ada28d" title="leading truck">ACTIVATED</a>) <span class="comment">//force feedback sensors</span>
<a name="l00433"></a>00433     {
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (doUpdate)
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436             affforce = 0;
<a name="l00437"></a>00437             affhydro = 0;
<a name="l00438"></a>00438         }
<a name="l00439"></a>00439         <span class="keywordflow">if</span> (currentcamera != -1)
<a name="l00440"></a>00440         {
<a name="l00441"></a>00441             affforce += nodes[cameranodepos[currentcamera]].Forces;
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_hydro; i++)
<a name="l00444"></a>00444         {
<a name="l00445"></a>00445             <span class="keywordflow">if</span> ((beams[hydro[i]].hydroFlags &amp; (<a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa3ff5ee8f96c1deeb47e8e7adc99604b3">HYDRO_FLAG_DIR</a>|<a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa109c779382844ca5fdb8e7be0f3c173a">HYDRO_FLAG_SPEED</a>)) &amp;&amp; !beams[hydro[i]].broken)
<a name="l00446"></a>00446                 affhydro += beams[hydro[i]].hydroRatio * beams[hydro[i]].refL * beams[hydro[i]].stress;
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448     }
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a><a class="code" href="class_beam.html#a320c734d97c1f21d1609078fadad680f">00451</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a320c734d97c1f21d1609078fadad680f">Beam::calcMouse</a>()
<a name="l00452"></a>00452 {
<a name="l00453"></a>00453     <span class="comment">//mouse stuff</span>
<a name="l00454"></a>00454     <span class="keywordflow">if</span> (mousenode != -1)
<a name="l00455"></a>00455     {
<a name="l00456"></a>00456         <a class="code" href="struct_vector3.html">Vector3</a> dir = mousepos - nodes[mousenode].AbsPosition;
<a name="l00457"></a>00457         nodes[mousenode].Forces += mousemoveforce * dir;
<a name="l00458"></a>00458     }
<a name="l00459"></a>00459 }
<a name="l00460"></a><a class="code" href="class_beam.html#afb510c8260d968477f30efbe18538076">00460</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#afb510c8260d968477f30efbe18538076">Beam::calcSlideNodes</a>(Ogre::Real dt)
<a name="l00461"></a>00461 {
<a name="l00462"></a>00462     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_SlideNodes);
<a name="l00463"></a>00463     updateSlideNodeForces(dt);
<a name="l00464"></a>00464     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_SlideNodes);
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a><a class="code" href="class_beam.html#a62af13a4d65178e0d9deeda425b048a6">00467</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a62af13a4d65178e0d9deeda425b048a6">Beam::calcNodes_</a>(<span class="keywordtype">bool</span> doUpdate, Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps)
<a name="l00468"></a>00468 {
<a name="l00469"></a>00469 <span class="preprocessor">#if NODES_INTER_TRUCK_PARALLEL</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span>    calcSlideNodes(dt);
<a name="l00471"></a>00471     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Nodes);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     watercontact = <span class="keyword">false</span>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="preprocessor">#if !NODES_INTRA_TRUCK_PARALLEL</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span>    calcNodes(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l00477"></a>00477 <span class="preprocessor">#else</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (free_node &lt; 50)
<a name="l00479"></a>00479     {
<a name="l00480"></a>00480         calcNodes(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l00481"></a>00481     } <span class="keywordflow">else</span>
<a name="l00482"></a>00482     {
<a name="l00483"></a>00483         runThreadTask(<span class="keyword">this</span>, THREAD_NODES, <span class="keyword">true</span>);
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485 <span class="preprocessor">#endif</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span>
<a name="l00487"></a>00487     Ogre::AxisAlignedBox tBoundingBox(nodes[0].AbsPosition.x, nodes[0].AbsPosition.y, nodes[0].AbsPosition.z, nodes[0].AbsPosition.x, nodes[0].AbsPosition.y, nodes[0].AbsPosition.z);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; collisionBoundingBoxes.size(); i++)
<a name="l00490"></a>00490     {
<a name="l00491"></a>00491         collisionBoundingBoxes[i].scale(Ogre::Vector3(0.0));
<a name="l00492"></a>00492     }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_node; i++)
<a name="l00495"></a>00495     {
<a name="l00496"></a>00496         tBoundingBox.merge(nodes[i].AbsPosition);
<a name="l00497"></a>00497         <span class="keywordflow">if</span> (nodes[i].collisionBoundingBoxID &gt;= 0 &amp;&amp; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) nodes[i].collisionBoundingBoxID &lt; collisionBoundingBoxes.size())
<a name="l00498"></a>00498         {
<a name="l00499"></a>00499             <span class="keywordflow">if</span> (collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].getSize().length() == 0.0 &amp;&amp; collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].getMinimum().length() == 0.0)
<a name="l00500"></a>00500             {
<a name="l00501"></a>00501                 collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].setExtents(nodes[i].AbsPosition.x, nodes[i].AbsPosition.y, nodes[i].AbsPosition.z, nodes[i].AbsPosition.x, nodes[i].AbsPosition.y, nodes[i].AbsPosition.z);
<a name="l00502"></a>00502             } <span class="keywordflow">else</span>
<a name="l00503"></a>00503             {
<a name="l00504"></a>00504                 collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].merge(nodes[i].AbsPosition);
<a name="l00505"></a>00505             }
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507     }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; collisionBoundingBoxes.size(); i++)
<a name="l00510"></a>00510     {
<a name="l00511"></a>00511         collisionBoundingBoxes[i].setMinimum(collisionBoundingBoxes[i].getMinimum() - <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l00512"></a>00512         collisionBoundingBoxes[i].setMaximum(collisionBoundingBoxes[i].getMaximum() + <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         predictedCollisionBoundingBoxes[i].setExtents(collisionBoundingBoxes[i].getMinimum(), collisionBoundingBoxes[i].getMaximum());
<a name="l00515"></a>00515         predictedCollisionBoundingBoxes[i].merge(collisionBoundingBoxes[i].getMinimum() + nodes[0].Velocity * dt);
<a name="l00516"></a>00516         predictedCollisionBoundingBoxes[i].merge(collisionBoundingBoxes[i].getMaximum() + nodes[0].Velocity * dt);
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="comment">// anti-explosion guard</span>
<a name="l00520"></a>00520     <span class="comment">// rationale behind 1e9 number:</span>
<a name="l00521"></a>00521     <span class="comment">// - while 1e6 is reachable by a fast vehicle, it will be badly deformed and shaking due to loss of precision in calculations</span>
<a name="l00522"></a>00522     <span class="comment">// - at 1e7 any typical RoR vehicle falls apart and stops functioning</span>
<a name="l00523"></a>00523     <span class="comment">// - 1e9 may be reachable only by a vehicle that is 1000 times bigger than a typical RoR vehicle, and it will be a loooong trip</span>
<a name="l00524"></a>00524     <span class="comment">// to be able to travel such long distances will require switching physics calculations to higher precision numbers</span>
<a name="l00525"></a>00525     <span class="comment">// or taking a different approach to the simulation (truck-local coordinate system?)</span>
<a name="l00526"></a>00526     <span class="keywordflow">if</span> (!inRange(tBoundingBox.getMinimum().x + tBoundingBox.getMaximum().x +
<a name="l00527"></a>00527         tBoundingBox.getMinimum().y + tBoundingBox.getMaximum().y +
<a name="l00528"></a>00528         tBoundingBox.getMinimum().z + tBoundingBox.getMaximum().z, -1e9, 1e9))
<a name="l00529"></a>00529     {
<a name="l00530"></a>00530         reset_requested = 1; <span class="comment">// truck exploded, schedule reset</span>
<a name="l00531"></a>00531         <span class="keywordflow">return</span>; <span class="comment">// return early to avoid propagating invalid values</span>
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     boundingBox.setMinimum(tBoundingBox.getMinimum() - <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l00535"></a>00535     boundingBox.setMaximum(tBoundingBox.getMaximum() + <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     predictedBoundingBox.setExtents(boundingBox.getMinimum(), boundingBox.getMaximum());
<a name="l00538"></a>00538     predictedBoundingBox.merge(boundingBox.getMinimum() + nodes[0].Velocity * dt);
<a name="l00539"></a>00539     predictedBoundingBox.merge(boundingBox.getMaximum() + nodes[0].Velocity * dt);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Nodes);
<a name="l00542"></a>00542 <span class="preprocessor">#endif</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>}
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="class_beam.html#a97a16e07a1fb5b7d1c2a7994d69497d4">00545</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a97a16e07a1fb5b7d1c2a7994d69497d4">Beam::calcAxles</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt)
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547     <span class="comment">// TODO Wheels and Axles share many variables, this was moved to calc</span>
<a name="l00548"></a>00548     <span class="comment">// Wheels until a better method is devised to share the information</span>
<a name="l00549"></a>00549     <span class="comment">// this is kept here to maintain the intended structure</span>
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a><a class="code" href="class_beam.html#a379812802400820db3690b5ff665ccaa">00552</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a379812802400820db3690b5ff665ccaa">Beam::calcTurboProp</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt)
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Turboprop);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="comment">//turboprop forces</span>
<a name="l00557"></a>00557     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_aeroengine; i++)
<a name="l00558"></a>00558         <span class="keywordflow">if</span> (aeroengines[i]) aeroengines[i]-&gt;updateForces(dt, doUpdate);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Turboprop);
<a name="l00561"></a>00561 }
<a name="l00562"></a>00562 
<a name="l00563"></a><a class="code" href="class_beam.html#acea0f9d0cc6aed28c8f8f6bb80ecc0ad">00563</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#acea0f9d0cc6aed28c8f8f6bb80ecc0ad">Beam::calcScrewProp</a>(<span class="keywordtype">bool</span> doUpdate)
<a name="l00564"></a>00564 {
<a name="l00565"></a>00565     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Screwprop);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567     <span class="comment">//screwprop forces</span>
<a name="l00568"></a>00568     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_screwprop; i++)
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (screwprops[i]) screwprops[i]-&gt;updateForces(doUpdate);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Screwprop);
<a name="l00572"></a>00572 }
<a name="l00573"></a>00573 
<a name="l00574"></a><a class="code" href="class_beam.html#af4d152cc908179a5d880abcf6738f6e4">00574</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#af4d152cc908179a5d880abcf6738f6e4">Beam::calcWing</a>()
<a name="l00575"></a>00575 {
<a name="l00576"></a>00576     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Wing);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578     <span class="comment">//wing forces</span>
<a name="l00579"></a>00579     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_wing; i++)
<a name="l00580"></a>00580         <span class="keywordflow">if</span> (wings[i].fa) wings[i].fa-&gt;updateForces();
<a name="l00581"></a>00581 
<a name="l00582"></a>00582     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Wing);
<a name="l00583"></a>00583 }
<a name="l00584"></a>00584 
<a name="l00585"></a><a class="code" href="class_beam.html#ad256fc99aa2ef3f2e34d1968762362ae">00585</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#ad256fc99aa2ef3f2e34d1968762362ae">Beam::calcFuseDrag</a>()
<a name="l00586"></a>00586 {
<a name="l00587"></a>00587     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_FuseDrag);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589     <span class="comment">//compute fuse drag</span>
<a name="l00590"></a>00590     <span class="keywordflow">if</span> (fuseAirfoil)
<a name="l00591"></a>00591     {
<a name="l00592"></a>00592         <a class="code" href="struct_vector3.html">Vector3</a> wind=-fuseFront-&gt;Velocity;
<a name="l00593"></a>00593         <span class="keywordtype">float</span> wspeed=wind.<a class="code" href="struct_vector3.html#a30db3d517cb422cb78a4be0cf52bc89e">length</a>();
<a name="l00594"></a>00594         <a class="code" href="struct_vector3.html">Vector3</a> axis=fuseFront-&gt;RelPosition-fuseBack-&gt;RelPosition;
<a name="l00595"></a>00595         <span class="keywordtype">float</span> s=axis.<a class="code" href="struct_vector3.html#a30db3d517cb422cb78a4be0cf52bc89e">length</a>()*fuseWidth;
<a name="l00596"></a>00596         <span class="keywordtype">float</span> cz, cx, cm;
<a name="l00597"></a>00597         <span class="keywordtype">float</span> v=axis.getRotationTo(wind).w;
<a name="l00598"></a>00598         <span class="keywordtype">float</span> aoa=0;
<a name="l00599"></a>00599         <span class="keywordflow">if</span> (v&lt;1.0 &amp;&amp; v&gt;-1.0) aoa=2.0*acos(v); <span class="comment">//quaternion fun</span>
<a name="l00600"></a>00600         fuseAirfoil-&gt;getparams(aoa, 1.0, 0.0, &amp;cz, &amp;cx, &amp;cm);
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         <span class="comment">//tropospheric model valid up to 11.000m (33.000ft)</span>
<a name="l00603"></a>00603         <span class="keywordtype">float</span> altitude=fuseFront-&gt;AbsPosition.y;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         <span class="comment">// TODO Unused Varaible</span>
<a name="l00606"></a>00606         <span class="comment">//float sea_level_temperature=273.15f+15.0f; //in Kelvin</span>
<a name="l00607"></a>00607         <span class="keywordtype">float</span> sea_level_pressure=101325; <span class="comment">//in Pa</span>
<a name="l00608"></a>00608 
<a name="l00609"></a>00609         <span class="comment">// TODO Unused Varaible</span>
<a name="l00610"></a>00610         <span class="comment">//float airtemperature=sea_level_temperature-altitude*0.0065f; //in Kelvin</span>
<a name="l00611"></a>00611         <span class="keywordtype">float</span> airpressure=sea_level_pressure*<a class="code" href="_approx_math_8h.html#aa827078e74a2a2b87a97a834d2359e88">approx_pow</a>(1.0-0.0065*altitude/288.1, 5.24947); <span class="comment">//in Pa</span>
<a name="l00612"></a>00612         <span class="keywordtype">float</span> airdensity=airpressure*0.0000120896f;<span class="comment">//1.225 at sea level</span>
<a name="l00613"></a>00613 
<a name="l00614"></a>00614         <span class="comment">//fuselage as an airfoil + parasitic drag (half fuselage front surface almost as a flat plane!)</span>
<a name="l00615"></a>00615         fusedrag=((cx*s+fuseWidth*fuseWidth*0.5)*0.5*airdensity*wspeed/free_node)*wind; <span class="comment">//free_node is never null</span>
<a name="l00616"></a>00616     }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_FuseDrag);
<a name="l00619"></a>00619     
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 
<a name="l00622"></a><a class="code" href="class_beam.html#a1b70130782be31aedd1caf46033da58d">00622</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a1b70130782be31aedd1caf46033da58d">Beam::calcAirBrakes</a>()
<a name="l00623"></a>00623 {
<a name="l00624"></a>00624     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Airbrakes);
<a name="l00625"></a>00625 
<a name="l00626"></a>00626     <span class="comment">//airbrakes</span>
<a name="l00627"></a>00627     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_airbrake; i++)
<a name="l00628"></a>00628     {
<a name="l00629"></a>00629         airbrakes[i]-&gt;applyForce();
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Airbrakes);
<a name="l00633"></a>00633 }
<a name="l00634"></a>00634 
<a name="l00635"></a><a class="code" href="class_beam.html#a1306e25664394683315e56468fe429eb">00635</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a1306e25664394683315e56468fe429eb">Beam::calcBuoyance</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span>)
<a name="l00636"></a>00636 {
<a name="l00637"></a>00637     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Buoyance);
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <a class="code" href="class_i_water.html">IWater</a> *water = (<a class="code" href="_main_thread_8cpp.html#aa88203d48340f609e6b6c7f1471f3b8e">gEnv</a>-&gt;<a class="code" href="class_global_environment.html#a23825f69e60897a660d18659399e0de2">terrainManager</a> ? <a class="code" href="_main_thread_8cpp.html#aa88203d48340f609e6b6c7f1471f3b8e">gEnv</a>-&gt;<a class="code" href="class_global_environment.html#a23825f69e60897a660d18659399e0de2">terrainManager</a>-&gt;<a class="code" href="class_terrain_manager.html#a1d0227a71a4e114099797646ff6756b7">getWater</a>() : <span class="keyword">nullptr</span>);
<a name="l00640"></a>00640     <span class="comment">//water buoyance</span>
<a name="l00641"></a>00641     <span class="keywordflow">if</span> (free_buoycab &amp;&amp; water)
<a name="l00642"></a>00642     {
<a name="l00643"></a>00643         <span class="keywordflow">if</span> (!(step%20))
<a name="l00644"></a>00644         {
<a name="l00645"></a>00645             <span class="comment">//clear forces</span>
<a name="l00646"></a>00646             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_buoycab; i++)
<a name="l00647"></a>00647             {
<a name="l00648"></a>00648                 <span class="keywordtype">int</span> tmpv=buoycabs[i]*3;
<a name="l00649"></a>00649                 nodes[cabs[tmpv]].buoyanceForce=0;
<a name="l00650"></a>00650                 nodes[cabs[tmpv+1]].buoyanceForce=0;
<a name="l00651"></a>00651                 nodes[cabs[tmpv+2]].buoyanceForce=0;
<a name="l00652"></a>00652             }
<a name="l00653"></a>00653             <span class="comment">//add forces</span>
<a name="l00654"></a>00654             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_buoycab; i++)
<a name="l00655"></a>00655             {
<a name="l00656"></a>00656                 <span class="keywordtype">int</span> tmpv=buoycabs[i]*3;
<a name="l00657"></a>00657                 buoyance-&gt;computeNodeForce(&amp;nodes[cabs[tmpv]], &amp;nodes[cabs[tmpv+1]], &amp;nodes[cabs[tmpv+2]], doUpdate, buoycabtypes[i]);
<a name="l00658"></a>00658             }
<a name="l00659"></a>00659         }
<a name="l00660"></a>00660         <span class="comment">//apply forces</span>
<a name="l00661"></a>00661         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_node; i++)
<a name="l00662"></a>00662         {
<a name="l00663"></a>00663             nodes[i].Forces+=nodes[i].buoyanceForce;
<a name="l00664"></a>00664         }
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Buoyance);
<a name="l00668"></a>00668 }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 
<a name="l00671"></a><a class="code" href="class_beam.html#a7c5a8085b41f7422ba4bca24846e5eb0">00671</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a7c5a8085b41f7422ba4bca24846e5eb0">Beam::calcWheels</a>(<span class="keywordtype">bool</span> doUpdate, Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps)
<a name="l00672"></a>00672 {
<a name="l00673"></a>00673     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Axles);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     <span class="comment">//wheel speed</span>
<a name="l00676"></a>00676     Real wspeed = 0.0;
<a name="l00677"></a>00677     <span class="comment">//wheel stuff</span>
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     <span class="keywordtype">float</span> engine_torque = 0.0;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681     <span class="comment">// calculate torque per wheel</span>
<a name="l00682"></a>00682     <span class="keywordflow">if</span> (engine &amp;&amp; proped_wheels != 0)
<a name="l00683"></a>00683         engine_torque = engine-&gt;getTorque() / proped_wheels;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685     <span class="keywordtype">int</span> propcounter = 0;
<a name="l00686"></a>00686     <span class="keywordtype">float</span> newspeeds[<a class="code" href="_beam_data_8h.html#a7bc15dd4ec4eb931d4e179788511fa3a" title="maximum number of wheels per truck">MAX_WHEELS</a>];
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     <span class="keywordtype">float</span> intertorque[<a class="code" href="_beam_data_8h.html#a7bc15dd4ec4eb931d4e179788511fa3a" title="maximum number of wheels per truck">MAX_WHEELS</a>] = {}; <span class="comment">//bad initialization</span>
<a name="l00689"></a>00689     <span class="comment">//old-style viscous code</span>
<a name="l00690"></a>00690     <span class="keywordflow">if</span> (free_axle == 0)
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692         <span class="comment">//first, evaluate torque from inter-differential locking</span>
<a name="l00693"></a>00693         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;proped_wheels/2-1; i++)
<a name="l00694"></a>00694         {
<a name="l00695"></a>00695             <span class="keywordtype">float</span> speed1=(wheels[proppairs[i*2]].speed+wheels[proppairs[i*2+1]].speed)*0.5f;
<a name="l00696"></a>00696             <span class="keywordtype">float</span> speed2=(wheels[proppairs[i*2+2]].speed+wheels[proppairs[i*2+3]].speed)*0.5f;
<a name="l00697"></a>00697             <span class="keywordtype">float</span> torque=(speed1-speed2)*10000.0f;
<a name="l00698"></a>00698             intertorque[i*2]-=torque*0.5f;
<a name="l00699"></a>00699             intertorque[i*2+1]-=torque*0.5f;
<a name="l00700"></a>00700             intertorque[i*2+2]+=torque*0.5f;
<a name="l00701"></a>00701             intertorque[i*2+3]+=torque*0.5f;
<a name="l00702"></a>00702         }
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <span class="comment">// new-style Axles</span>
<a name="l00706"></a>00706     <span class="comment">// loop through all axles for inter axle torque, this is the torsion to keep</span>
<a name="l00707"></a>00707     <span class="comment">// the axles aligned with each other as if they connected by a shaft</span>
<a name="l00708"></a>00708     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;free_axle; i++)
<a name="l00709"></a>00709     {
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (!axles[i]) <span class="keywordflow">continue</span>;
<a name="l00711"></a>00711         Ogre::Real axle_torques[2] = {0.0f, 0.0f};
<a name="l00712"></a>00712         <a class="code" href="structdifferential__data__t.html">differential_data_t</a> diff_data =
<a name="l00713"></a>00713         {
<a name="l00714"></a>00714             {
<a name="l00715"></a>00715                 (wheels[axles[i-1]-&gt;wheel_1].speed + wheels[axles[i-1]-&gt;wheel_2].speed) * 0.5f,
<a name="l00716"></a>00716                     (wheels[axles[i]-&gt;wheel_1].speed + wheels[axles[i]-&gt;wheel_2].speed) * 0.5f
<a name="l00717"></a>00717             },
<a name="l00718"></a>00718             axles[i-1]-&gt;<a class="code" href="structdifferential__data__t.html#acd36c76fdb78ac656f5ce3996430b968">delta_rotation</a>,
<a name="l00719"></a>00719                 { axle_torques[0], axle_torques[1] },
<a name="l00720"></a>00720                 0, <span class="comment">// no input torque, just calculate forces from different axle positions</span>
<a name="l00721"></a>00721                 dt
<a name="l00722"></a>00722         };
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="preprocessor">#if 0</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>        <span class="comment">// use an open diff just for fun :)</span>
<a name="l00726"></a>00726         <a class="code" href="class_axle.html#a555d076e3aa3bfe70f91d6d625d51de3" title="more power goes to the faster spining wheel">Axle::calcOpenDiff</a>( diff_data );
<a name="l00727"></a>00727 <span class="preprocessor">#else</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>        <span class="comment">// use the locked diff, most vehicles are setup this way...</span>
<a name="l00729"></a>00729         <a class="code" href="class_axle.html#a3053f4ee933712559c5306f6077b2d1b" title="ensures both wheels rotate at the the same speed">Axle::calcLockedDiff</a>( diff_data );
<a name="l00730"></a>00730 <span class="preprocessor">#endif</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>
<a name="l00732"></a>00732         axles[i-1]-&gt;delta_rotation = diff_data.<a class="code" href="structdifferential__data__t.html#acd36c76fdb78ac656f5ce3996430b968">delta_rotation</a>;
<a name="l00733"></a>00733         axles[i]-&gt;delta_rotation = -diff_data.<a class="code" href="structdifferential__data__t.html#acd36c76fdb78ac656f5ce3996430b968">delta_rotation</a>;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         intertorque[axles[i-1]-&gt;wheel_1] = diff_data.<a class="code" href="structdifferential__data__t.html#ab8063dd8b33f97b4d0da71aefa5db552">out_torque</a>[0];
<a name="l00736"></a>00736         intertorque[axles[i-1]-&gt;wheel_2] = diff_data.<a class="code" href="structdifferential__data__t.html#ab8063dd8b33f97b4d0da71aefa5db552">out_torque</a>[0];
<a name="l00737"></a>00737         intertorque[axles[i]-&gt;wheel_1] = diff_data.<a class="code" href="structdifferential__data__t.html#ab8063dd8b33f97b4d0da71aefa5db552">out_torque</a>[1];
<a name="l00738"></a>00738         intertorque[axles[i]-&gt;wheel_2] = diff_data.<a class="code" href="structdifferential__data__t.html#ab8063dd8b33f97b4d0da71aefa5db552">out_torque</a>[1];
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="comment">// loop through all the wheels (new style again)</span>
<a name="l00742"></a>00742     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_axle; i++)
<a name="l00743"></a>00743     {
<a name="l00744"></a>00744         <span class="keywordflow">if</span> (!axles[i]) <span class="keywordflow">continue</span>;
<a name="l00745"></a>00745         Ogre::Real axle_torques[2] = {0.0f, 0.0f};
<a name="l00746"></a>00746         <a class="code" href="structwheel__t.html">wheel_t</a> *axle_wheels[2] = { &amp;wheels[axles[i]-&gt;wheel_1], &amp;wheels[axles[i]-&gt;wheel_2] };
<a name="l00747"></a>00747 
<a name="l00748"></a>00748         <a class="code" href="structdifferential__data__t.html">differential_data_t</a> diff_data =
<a name="l00749"></a>00749         {
<a name="l00750"></a>00750             { axle_wheels[0]-&gt;<a class="code" href="structwheel__t.html#a475e195749d770e4cda5c7bf3f73c058">speed</a>, axle_wheels[1]-&gt;<a class="code" href="structwheel__t.html#a475e195749d770e4cda5c7bf3f73c058">speed</a> },
<a name="l00751"></a>00751             axle_wheels[0]-&gt;<a class="code" href="structwheel__t.html#ab41b763470e8213c6bc3ef5523fba023" title="Difference in wheel position.">delta_rotation</a>,
<a name="l00752"></a>00752             { axle_torques[0], axle_torques[1] },
<a name="l00753"></a>00753             <span class="comment">// twice the torque since this is for two wheels, plus extra torque from</span>
<a name="l00754"></a>00754             <span class="comment">// inter-axle torsion</span>
<a name="l00755"></a>00755             2.0f * engine_torque + intertorque[axles[i]-&gt;wheel_1],
<a name="l00756"></a>00756             dt
<a name="l00757"></a>00757         };
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         axles[i]-&gt;calcTorque( diff_data );
<a name="l00760"></a>00760 
<a name="l00761"></a>00761         axle_wheels[0]-&gt;<a class="code" href="structwheel__t.html#ab41b763470e8213c6bc3ef5523fba023" title="Difference in wheel position.">delta_rotation</a> = diff_data.<a class="code" href="structdifferential__data__t.html#acd36c76fdb78ac656f5ce3996430b968">delta_rotation</a>;
<a name="l00762"></a>00762         axle_wheels[1]-&gt;<a class="code" href="structwheel__t.html#ab41b763470e8213c6bc3ef5523fba023" title="Difference in wheel position.">delta_rotation</a> = -diff_data.<a class="code" href="structdifferential__data__t.html#acd36c76fdb78ac656f5ce3996430b968">delta_rotation</a>;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         intertorque[axles[i]-&gt;wheel_1] = diff_data.<a class="code" href="structdifferential__data__t.html#ab8063dd8b33f97b4d0da71aefa5db552">out_torque</a>[0];
<a name="l00765"></a>00765         intertorque[axles[i]-&gt;wheel_2] = diff_data.<a class="code" href="structdifferential__data__t.html#ab8063dd8b33f97b4d0da71aefa5db552">out_torque</a>[1];
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Axles);
<a name="l00769"></a>00769     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Wheels);
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="comment">// driving aids traction control &amp; anti-lock brake pulse</span>
<a name="l00772"></a>00772     tcalb_timer += dt;
<a name="l00773"></a>00773     <span class="keywordflow">if</span> (tcalb_timer &gt;= 25.0f)
<a name="l00774"></a>00774     {
<a name="l00775"></a>00775         tcalb_timer = 0.0f;
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timer = (int)(tcalb_timer * 2000.0f);
<a name="l00779"></a>00779     <span class="keywordflow">if</span> (!(timer % tc_pulse)) tc_pulse_state = !tc_pulse_state;
<a name="l00780"></a>00780     <span class="keywordflow">if</span> (!(timer % alb_pulse)) alb_pulse_state = !alb_pulse_state;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     tc_pulse_state = std::max(tc_pulse == 1, tc_pulse_state);
<a name="l00783"></a>00783     alb_pulse_state = std::max(alb_pulse == 1, alb_pulse_state);
<a name="l00784"></a>00784 
<a name="l00785"></a>00785     <span class="keywordtype">bool</span> tc_active = <span class="keyword">false</span>;
<a name="l00786"></a>00786     <span class="keywordtype">bool</span> alb_active = <span class="keyword">false</span>;
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     <span class="comment">// get current speed</span>
<a name="l00789"></a>00789     <span class="keywordtype">float</span> curspeed = nodes[0].Velocity.length();
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     <span class="comment">// fix for airplanes crashing when getAcc() is used</span>
<a name="l00792"></a>00792     <span class="keywordtype">float</span> currentAcc = 0.0f;
<a name="l00793"></a>00793     <span class="keywordflow">if</span> (driveable == <a class="code" href="_beam_data_8h.html#ae4d5251432e1a9e6803c0240cc492e18ad70431030b2ce25863bfad2f593091a6" title="its a truck">TRUCK</a> &amp;&amp; engine)
<a name="l00794"></a>00794     {
<a name="l00795"></a>00795         currentAcc = engine-&gt;getAcc();
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_wheel; i++)
<a name="l00799"></a>00799     {
<a name="l00800"></a>00800         Real speedacc = 0.0;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         <span class="comment">// total torque estimation</span>
<a name="l00803"></a>00803         Real total_torque = 0.0;
<a name="l00804"></a>00804         <span class="keywordflow">if</span> (wheels[i].propulsed &gt; 0)
<a name="l00805"></a>00805         {
<a name="l00806"></a>00806             total_torque = (free_axle == 0) ? engine_torque : intertorque[i];
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         <span class="comment">// braking</span>
<a name="l00810"></a>00810         <span class="comment">// ignore all braking code if the current wheel is not braked...</span>
<a name="l00811"></a>00811         <span class="keywordflow">if</span> (wheels[i].braked)
<a name="l00812"></a>00812         {
<a name="l00813"></a>00813             <span class="comment">// handbrake</span>
<a name="l00814"></a>00814             <span class="keywordtype">float</span> hbrake = 0.0f;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816             <span class="keywordflow">if</span> (parkingbrake &amp;&amp; wheels[i].braked != 4)
<a name="l00817"></a>00817             {
<a name="l00818"></a>00818                 hbrake = hbrakeforce;
<a name="l00819"></a>00819             }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821             <span class="comment">// directional braking</span>
<a name="l00822"></a>00822             <span class="keywordtype">float</span> dbrake = 0.0f;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824             <span class="keywordflow">if</span> (WheelSpeed &lt; 20.0f &amp;&amp; ((wheels[i].braked == 2 &amp;&amp; hydrodirstate &gt; 0.0f)
<a name="l00825"></a>00825                 || (wheels[i].braked == 3 &amp;&amp; hydrodirstate &lt; 0.0f)))
<a name="l00826"></a>00826             {
<a name="l00827"></a>00827                 dbrake = brakeforce * abs(hydrodirstate);
<a name="l00828"></a>00828             }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830             <span class="keywordflow">if</span> ((brake != 0.0 || dbrake != 0.0 || hbrake != 0.0) &amp;&amp; braked_wheels != 0)
<a name="l00831"></a>00831             {
<a name="l00832"></a>00832                 <span class="keywordflow">if</span> (curspeed &gt; 1.5f)
<a name="l00833"></a>00833                 {
<a name="l00834"></a>00834                     <span class="keywordtype">float</span> antilock_coef = 1.0f;
<a name="l00835"></a>00835                     wheels[i].firstLock = <span class="keyword">false</span>;
<a name="l00836"></a>00836                     <span class="keywordflow">if</span> (alb_mode &amp;&amp; alb_pulse_state &amp;&amp; curspeed &gt; alb_minspeed)
<a name="l00837"></a>00837                     {
<a name="l00838"></a>00838                         antilock_coef = fabs(wheels[i].speed) / curspeed;
<a name="l00839"></a>00839                         antilock_coef = pow(antilock_coef, alb_ratio);
<a name="l00840"></a>00840 
<a name="l00841"></a>00841                         <span class="comment">// limit brakeforce when wheels are in the air</span>
<a name="l00842"></a>00842                         antilock_coef = std::min(antilock_coef, 5.0f);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844                         alb_active = std::max(alb_active, (antilock_coef &lt; 0.9));
<a name="l00845"></a>00845                     }
<a name="l00846"></a>00846                     <span class="comment">// don&#39;t use to antilock_coef for handbrake</span>
<a name="l00847"></a>00847                     <span class="keywordflow">if</span> (wheels[i].speed &gt; 0)
<a name="l00848"></a>00848                         total_torque -= brake * antilock_coef + dbrake * antilock_coef + hbrake;
<a name="l00849"></a>00849                     <span class="keywordflow">else</span>
<a name="l00850"></a>00850                         total_torque += brake * antilock_coef + dbrake * antilock_coef + hbrake;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852                     <span class="keywordflow">if</span> (antilock_coef &gt;= 1.0f &amp;&amp; antilockbrake)
<a name="l00853"></a>00853                     {
<a name="l00854"></a>00854                         antilockbrake = !antilockbrake;
<a name="l00855"></a>00855                     }
<a name="l00856"></a>00856                 } <span class="keywordflow">else</span>
<a name="l00857"></a>00857                 {
<a name="l00858"></a>00858                     <span class="keywordflow">if</span> (fabs(wheels[i].speed) &gt; 0.0f)
<a name="l00859"></a>00859                     {
<a name="l00860"></a>00860                         total_torque -= (wheels[i].speed/fabs(wheels[i].speed))*(brake + dbrake + hbrake);
<a name="l00861"></a>00861                     }
<a name="l00862"></a>00862                     <span class="comment">// new halt position brake</span>
<a name="l00863"></a>00863                     <span class="keywordflow">if</span> (slopeBrake)
<a name="l00864"></a>00864                     {
<a name="l00865"></a>00865                         <span class="keywordflow">if</span>  (!wheels[i].firstLock)
<a name="l00866"></a>00866                         {
<a name="l00867"></a>00867                             <span class="comment">// first time here after a brake was attached, store the wheels rotation vector</span>
<a name="l00868"></a>00868                             wheels[i].firstLock = <span class="keyword">true</span>;
<a name="l00869"></a>00869                             wheels[i].lastRotationVec = <a class="code" href="_approx_math_8h.html#a88cab057c9c3a7a5cbaa1aebb06bf864">fast_normalise</a>(wheels[i].refnode0-&gt;RelPosition-wheels[i].nodes[0]-&gt;RelPosition);
<a name="l00870"></a>00870                         } <span class="keywordflow">else</span>
<a name="l00871"></a>00871                         {
<a name="l00872"></a>00872                             <span class="comment">// second time here after a brake was attached, determine offset angle the wheel has from last stored vector</span>
<a name="l00873"></a>00873                             <a class="code" href="struct_vector3.html">Vector3</a> lastwheelposition = wheels[i].lastRotationVec;
<a name="l00874"></a>00874                             <a class="code" href="struct_vector3.html">Vector3</a> wheelposition = <a class="code" href="_approx_math_8h.html#a88cab057c9c3a7a5cbaa1aebb06bf864">fast_normalise</a>(wheels[i].refnode0-&gt;RelPosition-wheels[i].nodes[0]-&gt;RelPosition);
<a name="l00875"></a>00875                             Radian anglerad = wheelposition.angleBetween(lastwheelposition);
<a name="l00876"></a>00876                             <span class="keywordtype">float</span> angle = anglerad.valueDegrees();
<a name="l00877"></a>00877 
<a name="l00878"></a>00878                             <span class="comment">// and now turn the wheel gently back into the stored position</span>
<a name="l00879"></a>00879                             <span class="keywordflow">if</span> (angle)
<a name="l00880"></a>00880                             {
<a name="l00881"></a>00881                                 <a class="code" href="struct_vector3.html">Vector3</a> dirv = (nodes[cameranodepos[0]].RelPosition-nodes[cameranodedir[0]].RelPosition).normalisedCopy();
<a name="l00882"></a>00882                                 Degree pitchangle = Radian(asin(dirv.dotProduct(Vector3::UNIT_Y)));
<a name="l00883"></a>00883 
<a name="l00884"></a>00884                                 <span class="comment">// avoid auto rotating the wheel, especially when steering while slopebraking</span>
<a name="l00885"></a>00885                                 <span class="keywordflow">if</span> (angle &gt; slopeBrakeRelAngle)
<a name="l00886"></a>00886                                 {
<a name="l00887"></a>00887                                     wheels[i].firstLock = <span class="keyword">false</span>;
<a name="l00888"></a>00888                                 }
<a name="l00889"></a>00889                                 <span class="keywordflow">if</span> (angle &gt; slopeBrakeAttAngle)
<a name="l00890"></a>00890                                 {
<a name="l00891"></a>00891                                     <span class="keywordtype">float</span> slopetorque = pow(angle - slopeBrakeAttAngle, slopeBrakeFactor);
<a name="l00892"></a>00892                                     slopetorque = std::min(slopetorque, brakeforce * 2.0f);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894                                     <span class="keywordflow">if</span> (pitchangle &gt; Degree(1))       <span class="comment">// we are rolling back</span>
<a name="l00895"></a>00895                                         total_torque += slopetorque;
<a name="l00896"></a>00896                                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pitchangle &lt; Degree(-1)) <span class="comment">// we are rolling forth</span>
<a name="l00897"></a>00897                                         total_torque -= slopetorque;
<a name="l00898"></a>00898                                 }
<a name="l00899"></a>00899                             }
<a name="l00900"></a>00900                         }
<a name="l00901"></a>00901                     }
<a name="l00902"></a>00902                 }
<a name="l00903"></a>00903             } <span class="keywordflow">else</span>
<a name="l00904"></a>00904             {
<a name="l00905"></a>00905                 <span class="comment">// all brakes are released, reset slopebrake firstLock</span>
<a name="l00906"></a>00906                 wheels[i].firstLock = <span class="keyword">false</span>;
<a name="l00907"></a>00907             }
<a name="l00908"></a>00908             <span class="comment">// the truck is still sliding and the brake might not locked the wheel yet (pbrake at high speed?)</span>
<a name="l00909"></a>00909             <span class="comment">// or the accelerator is pressed</span>
<a name="l00910"></a>00910             <span class="comment">// or the antilockbrake is still active</span>
<a name="l00911"></a>00911             <span class="comment">// -&gt; reset firstlock</span>
<a name="l00912"></a>00912             <span class="keywordflow">if</span> (fabs(curspeed) &gt; 0.75f || currentAcc &gt; 0.0f || alb_active)
<a name="l00913"></a>00913             {
<a name="l00914"></a>00914                 wheels[i].firstLock = <span class="keyword">false</span>;
<a name="l00915"></a>00915             }
<a name="l00916"></a>00916             <span class="comment">// reset alb_actibve after firstLock check!</span>
<a name="l00917"></a>00917             <span class="keywordflow">if</span> (hbrake != 0.0)
<a name="l00918"></a>00918             {
<a name="l00919"></a>00919                 alb_active = <span class="keyword">false</span>;
<a name="l00920"></a>00920             }
<a name="l00921"></a>00921         }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923         <span class="comment">// traction control, ignore tc code if wheel is not propulsed or accelerator is pressed</span>
<a name="l00924"></a>00924         <span class="keywordflow">if</span> (wheels[i].propulsed &gt; 0 &amp;&amp; tc_mode &amp;&amp; tc_pulse_state &amp;&amp; currentAcc &gt; 0.0f)
<a name="l00925"></a>00925         {
<a name="l00926"></a>00926             curspeed = std::max(0.5f, curspeed);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928             <span class="comment">// tc_wheelslip = allowed amount of slip in percent</span>
<a name="l00929"></a>00929             <span class="keywordtype">float</span> wheelslip = 1.0f + tc_wheelslip;
<a name="l00930"></a>00930             <span class="comment">// wheelslip allowed doubles up to tc_fade, a tribute to RoRs wheelspeed calculation and friction</span>
<a name="l00931"></a>00931             wheelslip += tc_wheelslip * (curspeed / tc_fade);
<a name="l00932"></a>00932             <span class="comment">// add wheelslip as activation offset</span>
<a name="l00933"></a>00933             <span class="keywordtype">float</span> torque_coef = (curspeed * wheelslip) / fabs(wheels[i].speed);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935             <span class="keywordflow">if</span> (torque_coef &lt; 1.0f)
<a name="l00936"></a>00936             {
<a name="l00937"></a>00937                 torque_coef = pow(torque_coef, tc_ratio);
<a name="l00938"></a>00938                 total_torque *= torque_coef;
<a name="l00939"></a>00939 
<a name="l00940"></a>00940                 tc_active = std::max(tc_active, torque_coef &lt; 0.9f);
<a name="l00941"></a>00941             }
<a name="l00942"></a>00942         }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944         <span class="comment">// old-style</span>
<a name="l00945"></a>00945         <span class="keywordflow">if</span> (free_axle == 0 &amp;&amp; wheels[i].propulsed &gt; 0)
<a name="l00946"></a>00946         {
<a name="l00947"></a>00947             <span class="comment">// differential locking</span>
<a name="l00948"></a>00948             <span class="keywordflow">if</span> (i%2)
<a name="l00949"></a>00949                 total_torque -= (wheels[i].speed - wheels[i-1].speed) * 10000.0;
<a name="l00950"></a>00950             <span class="keywordflow">else</span>
<a name="l00951"></a>00951                 total_torque -= (wheels[i].speed - wheels[i+1].speed) * 10000.0;
<a name="l00952"></a>00952             <span class="comment">// inter differential locking</span>
<a name="l00953"></a>00953             total_torque += intertorque[propcounter];
<a name="l00954"></a>00954             propcounter++;
<a name="l00955"></a>00955         }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         <span class="comment">// application to wheel</span>
<a name="l00958"></a>00958         <a class="code" href="struct_vector3.html">Vector3</a> axis = wheels[i].refnode1-&gt;RelPosition - wheels[i].refnode0-&gt;RelPosition;
<a name="l00959"></a>00959         <span class="keywordtype">float</span> axis_precalc = total_torque/(Real)(wheels[i].nbnodes);
<a name="l00960"></a>00960         axis = <a class="code" href="_approx_math_8h.html#a88cab057c9c3a7a5cbaa1aebb06bf864">fast_normalise</a>(axis);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;wheels[i].nbnodes; j++)
<a name="l00963"></a>00963         {
<a name="l00964"></a>00964             <a class="code" href="struct_vector3.html">Vector3</a> radius(Vector3::ZERO);
<a name="l00965"></a>00965 
<a name="l00966"></a>00966             <span class="keywordflow">if</span> (j%2)
<a name="l00967"></a>00967                 radius = wheels[i].nodes[j]-&gt;RelPosition - wheels[i].refnode1-&gt;RelPosition;
<a name="l00968"></a>00968             <span class="keywordflow">else</span>
<a name="l00969"></a>00969                 radius = wheels[i].nodes[j]-&gt;RelPosition - wheels[i].refnode0-&gt;RelPosition;
<a name="l00970"></a>00970 
<a name="l00971"></a>00971             <span class="keywordtype">float</span> inverted_rlen = <a class="code" href="_approx_math_8h.html#a08e9e14c091640464aae072f3823b855">fast_invSqrt</a>(radius.squaredLength());
<a name="l00972"></a>00972 
<a name="l00973"></a>00973             <span class="keywordflow">if</span> (wheels[i].propulsed==2)
<a name="l00974"></a>00974             {
<a name="l00975"></a>00975                 radius = -radius;
<a name="l00976"></a>00976             }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978             <a class="code" href="struct_vector3.html">Vector3</a> dir = axis.crossProduct(radius);
<a name="l00979"></a>00979             wheels[i].nodes[j]-&gt;Forces += dir * (axis_precalc*inverted_rlen*inverted_rlen);
<a name="l00980"></a>00980             <span class="comment">//wheel speed</span>
<a name="l00981"></a>00981             <span class="keywordflow">if</span> (j%2)
<a name="l00982"></a>00982                 speedacc += (wheels[i].nodes[j]-&gt;Velocity-wheels[i].refnode1-&gt;Velocity).dotProduct(dir) * inverted_rlen;
<a name="l00983"></a>00983             <span class="keywordflow">else</span>
<a name="l00984"></a>00984                 speedacc += (wheels[i].nodes[j]-&gt;Velocity-wheels[i].refnode0-&gt;Velocity).dotProduct(dir) * inverted_rlen;
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         <span class="comment">// wheel speed</span>
<a name="l00987"></a>00987         newspeeds[i] = speedacc / wheels[i].nbnodes;
<a name="l00988"></a>00988         <span class="keywordflow">if</span> (wheels[i].propulsed==1)
<a name="l00989"></a>00989         {
<a name="l00990"></a>00990             wspeed += newspeeds[i];
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992         <span class="comment">// for network</span>
<a name="l00993"></a>00993         wheels[i].rp += (newspeeds[i] / wheels[i].radius) * dt;
<a name="l00994"></a>00994         <span class="comment">// reaction torque</span>
<a name="l00995"></a>00995         <a class="code" href="struct_vector3.html">Vector3</a> rradius = wheels[i].arm-&gt;RelPosition - wheels[i].near_attach-&gt;RelPosition;
<a name="l00996"></a>00996         <a class="code" href="struct_vector3.html">Vector3</a> radius = Plane(axis, wheels[i].near_attach-&gt;RelPosition).projectVector(rradius);
<a name="l00997"></a>00997         Real rlen = radius.<a class="code" href="struct_vector3.html#a30db3d517cb422cb78a4be0cf52bc89e">length</a>(); <span class="comment">// length of the projected arm</span>
<a name="l00998"></a>00998         <span class="keywordtype">float</span> offset = (rradius-radius).length(); <span class="comment">// length of the error arm</span>
<a name="l00999"></a>00999         axis *= total_torque;
<a name="l01000"></a>01000         <span class="keywordflow">if</span> (rlen &gt; 0.01)
<a name="l01001"></a>01001         {
<a name="l01002"></a>01002             radius /= (2.0f * rlen * rlen);
<a name="l01003"></a>01003             <a class="code" href="struct_vector3.html">Vector3</a> cforce = axis.crossProduct(radius);
<a name="l01004"></a>01004             <span class="comment">// modulate the force according to induced torque error</span>
<a name="l01005"></a>01005             <span class="keywordflow">if</span> (offset * 2.0f &gt; rlen)
<a name="l01006"></a>01006                 cforce = Vector3::ZERO; <span class="comment">// too much error!</span>
<a name="l01007"></a>01007             <span class="keywordflow">else</span>
<a name="l01008"></a>01008                 cforce *= (1.0f - ((offset * 2.0f) / rlen)); <span class="comment">// linear modulation</span>
<a name="l01009"></a>01009             wheels[i].arm-&gt;Forces -= cforce;
<a name="l01010"></a>01010             wheels[i].near_attach-&gt;Forces += cforce;
<a name="l01011"></a>01011         }
<a name="l01012"></a>01012     }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014     <span class="comment">// dashboard overlays for tc+alb</span>
<a name="l01015"></a>01015     <span class="keywordflow">if</span> (doUpdate)
<a name="l01016"></a>01016     {
<a name="l01017"></a>01017         antilockbrake = <span class="keyword">false</span>;
<a name="l01018"></a>01018         tractioncontrol = <span class="keyword">false</span>;
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     antilockbrake = std::max(antilockbrake, (<span class="keywordtype">int</span>)alb_active);
<a name="l01022"></a>01022     tractioncontrol = std::max(tractioncontrol, (<span class="keywordtype">int</span>)tc_active);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <span class="keywordflow">if</span> (step == maxsteps)
<a name="l01025"></a>01025     {
<a name="l01026"></a>01026         <span class="keywordflow">if</span> (!antilockbrake)
<a name="l01027"></a>01027         {
<a name="l01028"></a>01028 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01029"></a>01029 <span class="preprocessor"></span>            SoundScriptManager::getSingleton().trigStop(trucknum, SS_TRIG_ALB_ACTIVE);
<a name="l01030"></a>01030 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>        } <span class="keywordflow">else</span>
<a name="l01032"></a>01032         {
<a name="l01033"></a>01033 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>            SoundScriptManager::getSingleton().trigStart(trucknum, SS_TRIG_ALB_ACTIVE);
<a name="l01035"></a>01035 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l01036"></a>01036 <span class="preprocessor"></span>        }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="keywordflow">if</span> (!tractioncontrol)
<a name="l01039"></a>01039         {
<a name="l01040"></a>01040 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01041"></a>01041 <span class="preprocessor"></span>            SoundScriptManager::getSingleton().trigStop(trucknum, SS_TRIG_TC_ACTIVE);
<a name="l01042"></a>01042 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l01043"></a>01043 <span class="preprocessor"></span>        } <span class="keywordflow">else</span>
<a name="l01044"></a>01044         {
<a name="l01045"></a>01045 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01046"></a>01046 <span class="preprocessor"></span>            SoundScriptManager::getSingleton().trigStart(trucknum, SS_TRIG_TC_ACTIVE);
<a name="l01047"></a>01047 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l01048"></a>01048 <span class="preprocessor"></span>        }
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_wheel; i++)
<a name="l01052"></a>01052     {
<a name="l01053"></a>01053         wheels[i].speed = newspeeds[i];
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055     <span class="keywordflow">if</span> (proped_wheels)
<a name="l01056"></a>01056     {
<a name="l01057"></a>01057         wspeed /= (float)proped_wheels;
<a name="l01058"></a>01058     }
<a name="l01059"></a>01059 
<a name="l01060"></a>01060     <span class="comment">// wheel speed  in m/s !</span>
<a name="l01061"></a>01061     WheelSpeed = wspeed;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063     <span class="keywordflow">if</span> (engine &amp;&amp; free_wheel &amp;&amp; wheels[0].radius &gt; 0.0f)
<a name="l01064"></a>01064     {
<a name="l01065"></a>01065         engine-&gt;setSpin(wspeed / wheels[0].radius * <a class="code" href="_beam_data_8h.html#af1b10cd8914c2fbd91c179c061c3491b" title="Convert radian/second to RPM (60/2*PI)">RAD_PER_SEC_TO_RPM</a>);
<a name="l01066"></a>01066     }
<a name="l01067"></a>01067 
<a name="l01068"></a>01068     <span class="comment">// calculate driven distance</span>
<a name="l01069"></a>01069     <span class="keywordtype">float</span> distance_driven = fabs(wspeed * dt);
<a name="l01070"></a>01070     odometerTotal += distance_driven;
<a name="l01071"></a>01071     odometerUser  += distance_driven;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Wheels);
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a><a class="code" href="class_beam.html#a9300de249095f934524a01fcb08c8809">01076</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a9300de249095f934524a01fcb08c8809">Beam::calcShocks</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt)
<a name="l01077"></a>01077 {
<a name="l01078"></a>01078     
<a name="l01079"></a>01079     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Shocks);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081     <span class="comment">//update position</span>
<a name="l01082"></a>01082     <span class="comment">//      if (free_node != 0)</span>
<a name="l01083"></a>01083     <span class="comment">//          aposition/=(Real)(free_node);</span>
<a name="l01084"></a>01084     <span class="comment">//variable shocks for stabilization</span>
<a name="l01085"></a>01085     <span class="keywordflow">if</span> (free_active_shock &amp;&amp; stabcommand)
<a name="l01086"></a>01086     {
<a name="l01087"></a>01087         <span class="keywordflow">if</span> ((stabcommand==1 &amp;&amp; stabratio&lt;0.1) || (stabcommand==-1 &amp;&amp; stabratio&gt;-0.1))
<a name="l01088"></a>01088             stabratio=stabratio+(float)stabcommand*dt*<a class="code" href="_beam_data_8h.html#a24ce347e3a2328c389c04b5598eb31c4">STAB_RATE</a>;
<a name="l01089"></a>01089         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_shock; i++)
<a name="l01090"></a>01090         {
<a name="l01091"></a>01091             <span class="comment">// active shocks now</span>
<a name="l01092"></a>01092             <span class="keywordflow">if</span> (shocks[i].flags &amp; <a class="code" href="_beam_data_8h.html#a0944a4353780132eeab7b06e3e42291da87cb137b9d9b1f920f2961d6b7da1f56">SHOCK_FLAG_RACTIVE</a>)
<a name="l01093"></a>01093                 beams[shocks[i].beamid].L=beams[shocks[i].beamid].refL*(1.0+stabratio);
<a name="l01094"></a>01094             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shocks[i].flags &amp; <a class="code" href="_beam_data_8h.html#a0944a4353780132eeab7b06e3e42291da8e19960237c16cfcae531d1e4f05a520">SHOCK_FLAG_LACTIVE</a>)
<a name="l01095"></a>01095                 beams[shocks[i].beamid].L=beams[shocks[i].beamid].refL*(1.0-stabratio);
<a name="l01096"></a>01096         }
<a name="l01097"></a>01097     }
<a name="l01098"></a>01098     <span class="comment">//auto shock adjust</span>
<a name="l01099"></a>01099     <span class="keywordflow">if</span> (free_active_shock &amp;&amp; doUpdate)
<a name="l01100"></a>01100     {
<a name="l01101"></a>01101         <a class="code" href="struct_vector3.html">Vector3</a> dir = nodes[cameranodepos[0]].RelPosition-nodes[cameranoderoll[0]].RelPosition;
<a name="l01102"></a>01102         dir.normalise();
<a name="l01103"></a>01103         <span class="keywordtype">float</span> roll = asin(dir.dotProduct(Vector3::UNIT_Y));
<a name="l01104"></a>01104         <span class="comment">//mWindow-&gt;setDebugText(&quot;Roll:&quot;+ TOSTRING(roll));</span>
<a name="l01105"></a>01105         <span class="keywordflow">if</span> (fabs(roll) &gt; 0.2)
<a name="l01106"></a>01106         {
<a name="l01107"></a>01107             stabsleep = -1.0; <span class="comment">//emergency timeout stop</span>
<a name="l01108"></a>01108         }
<a name="l01109"></a>01109         <span class="keywordflow">if</span> (fabs(roll) &gt; 0.01 &amp;&amp; stabsleep &lt; 0.0)
<a name="l01110"></a>01110         {
<a name="l01111"></a>01111             <span class="keywordflow">if</span> (roll&gt;0.0 &amp;&amp; stabcommand != -1)
<a name="l01112"></a>01112             {
<a name="l01113"></a>01113                 stabcommand = 1;
<a name="l01114"></a>01114             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (roll&lt;0.0 &amp;&amp; stabcommand != 1)
<a name="l01115"></a>01115             {
<a name="l01116"></a>01116                 stabcommand=-1; 
<a name="l01117"></a>01117             } <span class="keywordflow">else</span>
<a name="l01118"></a>01118             {
<a name="l01119"></a>01119                 stabcommand = 0;
<a name="l01120"></a>01120                 stabsleep = 3.0;
<a name="l01121"></a>01121             }
<a name="l01122"></a>01122         } <span class="keywordflow">else</span> 
<a name="l01123"></a>01123         {
<a name="l01124"></a>01124             stabcommand = 0;
<a name="l01125"></a>01125         }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01128"></a>01128 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (stabcommand &amp;&amp; fabs(stabratio) &lt; 0.1)
<a name="l01129"></a>01129             SoundScriptManager::getSingleton().trigStart(trucknum, SS_TRIG_AIR);
<a name="l01130"></a>01130         <span class="keywordflow">else</span>
<a name="l01131"></a>01131             SoundScriptManager::getSingleton().trigStop(trucknum, SS_TRIG_AIR);
<a name="l01132"></a>01132 <span class="preprocessor">#endif //OPENAL</span>
<a name="l01133"></a>01133 <span class="preprocessor"></span>    }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Shocks);
<a name="l01136"></a>01136     
<a name="l01137"></a>01137 }
<a name="l01138"></a>01138 
<a name="l01139"></a><a class="code" href="class_beam.html#a56da3edc4a944ad707937f3199ee3399">01139</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a56da3edc4a944ad707937f3199ee3399">Beam::calcHydros</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt)
<a name="l01140"></a>01140 {
<a name="l01141"></a>01141     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Hydros);
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <span class="comment">// TODO wspeed is calculated in calcwheels, need to find a sane way</span>
<a name="l01144"></a>01144     <span class="comment">// to get the value to this function </span>
<a name="l01145"></a>01145     Real wspeed = 0.0;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147     wspeed = WheelSpeed; <span class="comment">//getWheelSpeed()</span>
<a name="l01148"></a>01148 
<a name="l01149"></a>01149     <span class="comment">//direction</span>
<a name="l01150"></a>01150     <span class="keywordflow">if</span> (hydrodirstate!=0 || hydrodircommand!=0)
<a name="l01151"></a>01151     {
<a name="l01152"></a>01152         <span class="keywordtype">float</span> rate=1;
<a name="l01153"></a>01153         <span class="keywordflow">if</span> (hydroSpeedCoupling)
<a name="l01154"></a>01154         {
<a name="l01155"></a>01155             <span class="comment">//new rate value (30 instead of 40) to deal with the changed cmdKeyInertia settings</span>
<a name="l01156"></a>01156             rate=30.0/(10.0+fabs(wspeed/2.0));
<a name="l01157"></a>01157             <span class="comment">// minimum rate: 20% --&gt; enables to steer high velocity trucks</span>
<a name="l01158"></a>01158             <span class="keywordflow">if</span> (rate&lt;1.2) rate = 1.2;
<a name="l01159"></a>01159         }
<a name="l01160"></a>01160         <span class="comment">//need a maximum rate for analog devices, otherwise hydro beams break</span>
<a name="l01161"></a>01161         <span class="keywordflow">if</span> (!hydroSpeedCoupling)
<a name="l01162"></a>01162         {
<a name="l01163"></a>01163             <span class="keywordtype">float</span> hydrodirstateOld = hydrodirstate;
<a name="l01164"></a>01164             hydrodirstate = hydrodircommand;
<a name="l01165"></a>01165             <span class="keywordflow">if</span> (abs(hydrodirstate-hydrodirstateOld) &gt; 0.02)
<a name="l01166"></a>01166             {
<a name="l01167"></a>01167                 hydrodirstate = (hydrodirstate - hydrodirstateOld) * 0.02 + hydrodirstateOld;
<a name="l01168"></a>01168             }
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170         <span class="keywordflow">if</span> ( hydrodircommand!=0 &amp;&amp; hydroSpeedCoupling)
<a name="l01171"></a>01171         {
<a name="l01172"></a>01172             <span class="keywordflow">if</span> (hydrodirstate &gt; hydrodircommand)
<a name="l01173"></a>01173                 hydrodirstate -= dt * rate;
<a name="l01174"></a>01174             <span class="keywordflow">else</span>
<a name="l01175"></a>01175                 hydrodirstate += dt * rate;
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177         <span class="keywordflow">if</span> (hydroSpeedCoupling)
<a name="l01178"></a>01178         {
<a name="l01179"></a>01179             <span class="keywordtype">float</span> dirdelta=dt;
<a name="l01180"></a>01180             <span class="keywordflow">if</span>      (hydrodirstate &gt;  dirdelta) hydrodirstate -= dirdelta;
<a name="l01181"></a>01181             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hydrodirstate &lt; -dirdelta) hydrodirstate += dirdelta;
<a name="l01182"></a>01182             <span class="keywordflow">else</span> hydrodirstate = 0;
<a name="l01183"></a>01183         }
<a name="l01184"></a>01184     }
<a name="l01185"></a>01185     <span class="comment">//aileron</span>
<a name="l01186"></a>01186     <span class="keywordflow">if</span> (hydroaileronstate!=0 || hydroaileroncommand!=0)
<a name="l01187"></a>01187     {
<a name="l01188"></a>01188         <span class="keywordflow">if</span> (hydroaileroncommand!=0)
<a name="l01189"></a>01189         {
<a name="l01190"></a>01190             <span class="keywordflow">if</span> (hydroaileronstate &gt; hydroaileroncommand)
<a name="l01191"></a>01191                 hydroaileronstate -= dt*4.0;
<a name="l01192"></a>01192             <span class="keywordflow">else</span>
<a name="l01193"></a>01193                 hydroaileronstate += dt*4.0;
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195         <span class="keywordtype">float</span> delta = dt;
<a name="l01196"></a>01196         <span class="keywordflow">if</span>      (hydroaileronstate &gt;  delta) hydroaileronstate -= delta;
<a name="l01197"></a>01197         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hydroaileronstate &lt; -delta) hydroaileronstate += delta;
<a name="l01198"></a>01198         <span class="keywordflow">else</span> hydroaileronstate = 0;
<a name="l01199"></a>01199     }
<a name="l01200"></a>01200     <span class="comment">//rudder</span>
<a name="l01201"></a>01201     <span class="keywordflow">if</span> (hydrorudderstate!=0 || hydroruddercommand!=0)
<a name="l01202"></a>01202     {
<a name="l01203"></a>01203         <span class="keywordflow">if</span> (hydroruddercommand!=0)
<a name="l01204"></a>01204         {
<a name="l01205"></a>01205             <span class="keywordflow">if</span> (hydrorudderstate &gt; hydroruddercommand)
<a name="l01206"></a>01206                 hydrorudderstate -= dt*4.0;
<a name="l01207"></a>01207             <span class="keywordflow">else</span>
<a name="l01208"></a>01208                 hydrorudderstate += dt*4.0;
<a name="l01209"></a>01209         }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211         <span class="keywordtype">float</span> delta = dt;
<a name="l01212"></a>01212         <span class="keywordflow">if</span>      (hydrorudderstate &gt;  delta) hydrorudderstate -= delta;
<a name="l01213"></a>01213         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hydrorudderstate &lt; -delta) hydrorudderstate += delta;
<a name="l01214"></a>01214         <span class="keywordflow">else</span> hydrorudderstate = 0;
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216     <span class="comment">//elevator</span>
<a name="l01217"></a>01217     <span class="keywordflow">if</span> (hydroelevatorstate!=0 || hydroelevatorcommand!=0)
<a name="l01218"></a>01218     {
<a name="l01219"></a>01219         <span class="keywordflow">if</span> (hydroelevatorcommand!=0)
<a name="l01220"></a>01220         {
<a name="l01221"></a>01221             <span class="keywordflow">if</span> (hydroelevatorstate &gt; hydroelevatorcommand)
<a name="l01222"></a>01222                 hydroelevatorstate -= dt*4.0;
<a name="l01223"></a>01223             <span class="keywordflow">else</span>
<a name="l01224"></a>01224                 hydroelevatorstate += dt*4.0;
<a name="l01225"></a>01225         }
<a name="l01226"></a>01226         <span class="keywordtype">float</span> delta = dt;
<a name="l01227"></a>01227         <span class="keywordflow">if</span>      (hydroelevatorstate &gt;  delta) hydroelevatorstate -= delta;
<a name="l01228"></a>01228         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hydroelevatorstate &lt; -delta) hydroelevatorstate += delta;
<a name="l01229"></a>01229         <span class="keywordflow">else</span> hydroelevatorstate = 0;
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231     <span class="comment">//update length, dirstate between -1.0 and 1.0</span>
<a name="l01232"></a>01232     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_hydro; i++)
<a name="l01233"></a>01233     {
<a name="l01234"></a>01234         <span class="comment">//compound hydro</span>
<a name="l01235"></a>01235         <span class="keywordtype">float</span> cstate = 0.0f;
<a name="l01236"></a>01236         <span class="keywordtype">int</span> div = 0;
<a name="l01237"></a>01237         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa109c779382844ca5fdb8e7be0f3c173a">HYDRO_FLAG_SPEED</a>)
<a name="l01238"></a>01238         {
<a name="l01239"></a>01239             <span class="comment">//special treatment for SPEED</span>
<a name="l01240"></a>01240             <span class="keywordflow">if</span> (WheelSpeed &lt; 12.0f)
<a name="l01241"></a>01241                 cstate += hydrodirstate * (12.0f - WheelSpeed) / 12.0f;
<a name="l01242"></a>01242             div++;
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa3ff5ee8f96c1deeb47e8e7adc99604b3">HYDRO_FLAG_DIR</a>) {cstate+=hydrodirstate;div++;}
<a name="l01245"></a>01245         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa5e151cf7a0debbb376cc9aefb2ac00a0">HYDRO_FLAG_AILERON</a>) {cstate+=hydroaileronstate;div++;}
<a name="l01246"></a>01246         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fad3517a02da9fa3d66507e9d7fa1a20c1">HYDRO_FLAG_RUDDER</a>) {cstate+=hydrorudderstate;div++;}
<a name="l01247"></a>01247         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fad07b12ce2e80bae31ccd567f10c0d663">HYDRO_FLAG_ELEVATOR</a>) {cstate+=hydroelevatorstate;div++;}
<a name="l01248"></a>01248         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fab3616d71cf1f0d815a7b1f33ca4d3c37">HYDRO_FLAG_REV_AILERON</a>) {cstate-=hydroaileronstate;div++;}
<a name="l01249"></a>01249         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa2e6985fce325898bde8121b04e927d79">HYDRO_FLAG_REV_RUDDER</a>) {cstate-=hydrorudderstate;div++;}
<a name="l01250"></a>01250         <span class="keywordflow">if</span> (beams[hydro[i]].hydroFlags &amp; <a class="code" href="_beam_data_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa315c87a8576f94e81c56094f0eb9ce96">HYDRO_FLAG_REV_ELEVATOR</a>) {cstate-=hydroelevatorstate;div++;}
<a name="l01251"></a>01251 
<a name="l01252"></a>01252         <span class="keywordflow">if</span> (cstate &gt;  1.0) cstate =  1.0;
<a name="l01253"></a>01253         <span class="keywordflow">if</span> (cstate &lt; -1.0) cstate = -1.0;
<a name="l01254"></a>01254         <span class="comment">// Animators following, if no animator, skip all the tests...</span>
<a name="l01255"></a>01255         <span class="keywordtype">int</span> flagstate = beams[hydro[i]].animFlags;
<a name="l01256"></a>01256         <span class="keywordflow">if</span> (flagstate)
<a name="l01257"></a>01257         {
<a name="l01258"></a>01258             <span class="keywordtype">float</span> animoption = beams[hydro[i]].animOption;
<a name="l01259"></a>01259             calcAnimators(flagstate, cstate, div, dt, 0.0f, 0.0f, animoption);
<a name="l01260"></a>01260         }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262         <span class="keywordflow">if</span> (div)
<a name="l01263"></a>01263         {
<a name="l01264"></a>01264             cstate /= (float)div;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266             <span class="keywordflow">if</span> (hydroInertia)
<a name="l01267"></a>01267                 cstate=hydroInertia-&gt;calcCmdKeyDelay(cstate,i,dt);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269             <span class="keywordflow">if</span> (!(beams[hydro[i]].hydroFlags &amp; HYDRO_FLAG_SPEED))
<a name="l01270"></a>01270                 hydrodirwheeldisplay=cstate;
<a name="l01271"></a>01271 
<a name="l01272"></a>01272             <span class="keywordtype">float</span> factor = 1.0-cstate*beams[hydro[i]].hydroRatio;
<a name="l01273"></a>01273 
<a name="l01274"></a>01274             <span class="comment">// check and apply animators limits if set</span>
<a name="l01275"></a>01275             <span class="keywordflow">if</span> (flagstate)
<a name="l01276"></a>01276             {
<a name="l01277"></a>01277                 <span class="keywordflow">if</span> (factor &lt; 1.0f - beams[hydro[i]].shortbound)
<a name="l01278"></a>01278                     factor = 1.0f - beams[hydro[i]].shortbound;
<a name="l01279"></a>01279                 <span class="keywordflow">if</span> (factor &gt; 1.0f + beams[hydro[i]].longbound)
<a name="l01280"></a>01280                     factor = 1.0f + beams[hydro[i]].longbound;
<a name="l01281"></a>01281             }
<a name="l01282"></a>01282 
<a name="l01283"></a>01283             beams[hydro[i]].L=beams[hydro[i]].Lhydro * factor;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285         }
<a name="l01286"></a>01286     }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Hydros);
<a name="l01289"></a>01289 }
<a name="l01290"></a>01290 
<a name="l01291"></a><a class="code" href="class_beam.html#a7318cf1edaeb8e749a88e5bdc7d6cee4">01291</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a7318cf1edaeb8e749a88e5bdc7d6cee4">Beam::calcCommands</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt)
<a name="l01292"></a>01292 {
<a name="l01293"></a>01293     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Commands);
<a name="l01294"></a>01294 
<a name="l01295"></a>01295     <span class="comment">// commands</span>
<a name="l01296"></a>01296     <span class="keywordflow">if</span> (hascommands)
<a name="l01297"></a>01297     {
<a name="l01298"></a>01298         <span class="keywordtype">int</span> active = 0;
<a name="l01299"></a>01299         <span class="keywordtype">int</span> requested = 0;
<a name="l01300"></a>01300         <span class="keywordtype">float</span> work = 0.0;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302         <span class="comment">// canwork</span>
<a name="l01303"></a>01303         <span class="keywordflow">if</span> (engine)
<a name="l01304"></a>01304             canwork = engine-&gt;getRPM() &gt; engine-&gt;getIdleRPM() * 0.95f;
<a name="l01305"></a>01305         <span class="keywordflow">else</span>
<a name="l01306"></a>01306             canwork = <span class="keyword">true</span>;
<a name="l01307"></a>01307 
<a name="l01308"></a>01308         <span class="comment">// crankfactor</span>
<a name="l01309"></a>01309         <span class="keywordtype">float</span> crankfactor = 1.0f;
<a name="l01310"></a>01310         <span class="keywordflow">if</span> (engine)
<a name="l01311"></a>01311             crankfactor = engine-&gt;getCrankFactor();
<a name="l01312"></a>01312 
<a name="l01313"></a>01313         <span class="comment">// speed up machines</span>
<a name="l01314"></a>01314         <span class="keywordflow">if</span> (driveable==<a class="code" href="_beam_data_8h.html#ae4d5251432e1a9e6803c0240cc492e18adf02ded475565758943c5d421224efec" title="its a machine">MACHINE</a>)
<a name="l01315"></a>01315             crankfactor = 2;
<a name="l01316"></a>01316 
<a name="l01317"></a>01317         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;=<a class="code" href="_beam_data_8h.html#ab666a57e1a89c01fb894ac44469612ba" title="maximum number of commands per truck">MAX_COMMANDS</a>; i++)
<a name="l01318"></a>01318         {
<a name="l01319"></a>01319             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; (int)commandkey[i].beams.size(); j++)
<a name="l01320"></a>01320             {
<a name="l01321"></a>01321                 <span class="keywordtype">int</span> k = abs(commandkey[i].beams[j]);
<a name="l01322"></a>01322                 <span class="keywordflow">if</span> (k &gt;= 0 &amp;&amp; k &lt; free_beam)
<a name="l01323"></a>01323                 {
<a name="l01324"></a>01324                     beams[k].autoMoveLock = <span class="keyword">false</span>;
<a name="l01325"></a>01325                 }
<a name="l01326"></a>01326             }
<a name="l01327"></a>01327         }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;=<a class="code" href="_beam_data_8h.html#ab666a57e1a89c01fb894ac44469612ba" title="maximum number of commands per truck">MAX_COMMANDS</a>; i++)
<a name="l01330"></a>01330         {
<a name="l01331"></a>01331             <span class="keywordtype">float</span> oldValue = commandkey[i].commandValue;
<a name="l01332"></a>01332 
<a name="l01333"></a>01333             commandkey[i].commandValue = std::max(commandkey[i].playerInputValue, commandkey[i].triggerInputValue);
<a name="l01334"></a>01334 
<a name="l01335"></a>01335             commandkey[i].triggerInputValue = 0.0f;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337             <span class="keywordflow">if</span> (commandkey[i].commandValue &gt; 0.01f &amp;&amp; oldValue &lt; 0.01f)
<a name="l01338"></a>01338             {
<a name="l01339"></a>01339                 <span class="comment">// just started</span>
<a name="l01340"></a>01340                 commandkey[i].commandValueState = 1;
<a name="l01341"></a>01341             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandkey[i].commandValue &lt; 0.01f &amp;&amp; oldValue &gt; 0.01f)
<a name="l01342"></a>01342             {
<a name="l01343"></a>01343                 <span class="comment">// just stopped</span>
<a name="l01344"></a>01344                 commandkey[i].commandValueState = -1;
<a name="l01345"></a>01345             }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; (int)commandkey[i].beams.size(); j++)
<a name="l01348"></a>01348             {
<a name="l01349"></a>01349                 <span class="keywordflow">if</span> (commandkey[i].commandValue &gt;= 0.5)
<a name="l01350"></a>01350                 {
<a name="l01351"></a>01351                     <span class="keywordtype">int</span> k = abs(commandkey[i].beams[j]);
<a name="l01352"></a>01352                     <span class="keywordflow">if</span> (k &gt;= 0 &amp;&amp; k &lt; free_beam)
<a name="l01353"></a>01353                     {
<a name="l01354"></a>01354                         beams[k].autoMoveLock = <span class="keyword">true</span>;
<a name="l01355"></a>01355                     }
<a name="l01356"></a>01356                 }
<a name="l01357"></a>01357             }
<a name="l01358"></a>01358         }
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         <span class="comment">// only process ties if there is enough force available &lt;- why are ties related to engine rpm?</span>
<a name="l01361"></a>01361         <span class="keywordflow">if</span> (canwork)
<a name="l01362"></a>01362         {
<a name="l01363"></a>01363             <span class="keywordtype">bool</span> requestpower = <span class="keyword">false</span>;
<a name="l01364"></a>01364             <span class="comment">// go through all ties and process them</span>
<a name="l01365"></a>01365             <span class="keywordflow">for</span> (std::vector&lt;tie_t&gt;::iterator it=ties.begin(); it!=ties.end(); it++)
<a name="l01366"></a>01366             {
<a name="l01367"></a>01367                 <span class="comment">// only process tying ties</span>
<a name="l01368"></a>01368                 <span class="keywordflow">if</span> (!it-&gt;tying) <span class="keywordflow">continue</span>;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370                 <span class="comment">// division through zero guard</span>
<a name="l01371"></a>01371                 <span class="keywordflow">if</span> (it-&gt;beam-&gt;refL == 0 || it-&gt;beam-&gt;L == 0) <span class="keywordflow">continue</span>;
<a name="l01372"></a>01372 
<a name="l01373"></a>01373                 <span class="keywordtype">float</span> clen = it-&gt;beam-&gt;L / it-&gt;beam-&gt;refL;
<a name="l01374"></a>01374                 <span class="keywordflow">if</span> (clen &gt; it-&gt;beam-&gt;commandShort)
<a name="l01375"></a>01375                 {
<a name="l01376"></a>01376                     <span class="keywordtype">float</span> dl = it-&gt;beam-&gt;L;
<a name="l01377"></a>01377                     it-&gt;beam-&gt;L *= (1.0 - it-&gt;beam-&gt;commandRatioShort * dt / it-&gt;beam-&gt;L);
<a name="l01378"></a>01378                     dl = fabs(dl - it-&gt;beam-&gt;L);
<a name="l01379"></a>01379                     requestpower = <span class="keyword">true</span>;
<a name="l01380"></a>01380                     active++;
<a name="l01381"></a>01381                     work += fabs(it-&gt;beam-&gt;stress) * dl;
<a name="l01382"></a>01382                 } <span class="keywordflow">else</span>
<a name="l01383"></a>01383                 {
<a name="l01384"></a>01384                     <span class="comment">// tying finished, end reached</span>
<a name="l01385"></a>01385                     it-&gt;tying = <span class="keyword">false</span>;
<a name="l01386"></a>01386                 }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388                 <span class="comment">// check if we hit a certain force limit, then abort the tying process</span>
<a name="l01389"></a>01389                 <span class="keywordflow">if</span> (fabs(it-&gt;beam-&gt;stress) &gt; it-&gt;beam-&gt;maxtiestress)
<a name="l01390"></a>01390                     it-&gt;tying = <span class="keyword">false</span>;
<a name="l01391"></a>01391             }
<a name="l01392"></a>01392             <span class="keywordflow">if</span> (requestpower)
<a name="l01393"></a>01393                 requested++;
<a name="l01394"></a>01394         }
<a name="l01395"></a>01395 
<a name="l01396"></a>01396         <span class="comment">// now process normal commands</span>
<a name="l01397"></a>01397         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;=<a class="code" href="_beam_data_8h.html#ab666a57e1a89c01fb894ac44469612ba" title="maximum number of commands per truck">MAX_COMMANDS</a>; i++)
<a name="l01398"></a>01398         {
<a name="l01399"></a>01399             <span class="keywordtype">bool</span> requestpower = <span class="keyword">false</span>;
<a name="l01400"></a>01400             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; (int)commandkey[i].beams.size(); j++)
<a name="l01401"></a>01401             {
<a name="l01402"></a>01402                 <span class="keywordtype">int</span> bbeam_dir = (commandkey[i].beams[j] &gt; 0) ? 1 : -1;
<a name="l01403"></a>01403                 <span class="keywordtype">int</span> bbeam = std::abs(commandkey[i].beams[j]);
<a name="l01404"></a>01404 
<a name="l01405"></a>01405                 <span class="keywordflow">if</span> (bbeam &gt; free_beam) <span class="keywordflow">continue</span>;
<a name="l01406"></a>01406 
<a name="l01407"></a>01407                 <span class="comment">// restrict forces</span>
<a name="l01408"></a>01408                 <span class="keywordflow">if</span> (beams[bbeam].isForceRestricted)
<a name="l01409"></a>01409                     crankfactor = std::min(crankfactor, 1.0f);
<a name="l01410"></a>01410 
<a name="l01411"></a>01411                 <span class="keywordtype">float</span> v  = commandkey[i].commandValue;
<a name="l01412"></a>01412                 <span class="keywordtype">int</span> &amp;vst = commandkey[i].commandValueState;
<a name="l01413"></a>01413 
<a name="l01414"></a>01414                 <span class="comment">// self centering</span>
<a name="l01415"></a>01415                 <span class="keywordflow">if</span> (beams[bbeam].isCentering &amp;&amp; !beams[bbeam].autoMoveLock)
<a name="l01416"></a>01416                 {
<a name="l01417"></a>01417                     <span class="comment">// check for some error</span>
<a name="l01418"></a>01418                     <span class="keywordflow">if</span> (beams[bbeam].refL == 0 || beams[bbeam].L == 0)
<a name="l01419"></a>01419                         <span class="keywordflow">continue</span>;
<a name="l01420"></a>01420 
<a name="l01421"></a>01421                     <span class="keywordtype">float</span> current = (beams[bbeam].L / beams[bbeam].refL);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423                     <span class="keywordflow">if</span> (fabs(current-beams[bbeam].centerLength) &lt; 0.0001)
<a name="l01424"></a>01424                     {
<a name="l01425"></a>01425                         <span class="comment">// hold condition</span>
<a name="l01426"></a>01426                         beams[bbeam].autoMovingMode = 0;
<a name="l01427"></a>01427                     } <span class="keywordflow">else</span>
<a name="l01428"></a>01428                     {
<a name="l01429"></a>01429                         <span class="comment">// determine direction</span>
<a name="l01430"></a>01430                         <span class="keywordflow">if</span> (current &gt; beams[bbeam].centerLength)
<a name="l01431"></a>01431                             beams[bbeam].autoMovingMode = -1;
<a name="l01432"></a>01432                         <span class="keywordflow">else</span>
<a name="l01433"></a>01433                             beams[bbeam].autoMovingMode = 1;
<a name="l01434"></a>01434                     }
<a name="l01435"></a>01435                 }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437                 <span class="keywordflow">if</span> (beams[bbeam].refL != 0 &amp;&amp; beams[bbeam].L != 0)
<a name="l01438"></a>01438                 {
<a name="l01439"></a>01439                     <span class="keywordtype">float</span> clen = beams[bbeam].L / beams[bbeam].refL;
<a name="l01440"></a>01440                     <span class="keywordflow">if</span> ((bbeam_dir &gt; 0 &amp;&amp; clen &lt; beams[bbeam].commandLong) || (bbeam_dir &lt; 0 &amp;&amp; clen &gt; beams[bbeam].commandShort))
<a name="l01441"></a>01441                     {
<a name="l01442"></a>01442                         <span class="keywordtype">float</span> dl=beams[bbeam].L;
<a name="l01443"></a>01443 
<a name="l01444"></a>01444                         <span class="keywordflow">if</span> (beams[bbeam].isOnePressMode==2)
<a name="l01445"></a>01445                         {
<a name="l01446"></a>01446                             <span class="comment">// one press + centering</span>
<a name="l01447"></a>01447                             <span class="keywordflow">if</span> (bbeam_dir*beams[bbeam].autoMovingMode &gt; 0 &amp;&amp; bbeam_dir*clen &gt; bbeam_dir*beams[bbeam].centerLength &amp;&amp; !beams[bbeam].pressedCenterMode)
<a name="l01448"></a>01448                             {
<a name="l01449"></a>01449                                 beams[bbeam].pressedCenterMode = <span class="keyword">true</span>;
<a name="l01450"></a>01450                                 beams[bbeam].autoMovingMode = 0;
<a name="l01451"></a>01451                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bbeam_dir*beams[bbeam].autoMovingMode &lt; 0 &amp;&amp; bbeam_dir*clen &gt; bbeam_dir*beams[bbeam].centerLength &amp;&amp; beams[bbeam].pressedCenterMode)
<a name="l01452"></a>01452                             {
<a name="l01453"></a>01453                                 beams[bbeam].pressedCenterMode = <span class="keyword">false</span>;
<a name="l01454"></a>01454                             }
<a name="l01455"></a>01455                         }
<a name="l01456"></a>01456                         <span class="keywordflow">if</span> (beams[bbeam].isOnePressMode &gt; 0)
<a name="l01457"></a>01457                         {
<a name="l01458"></a>01458                             <span class="keywordtype">bool</span> key = (v &gt; 0.5);
<a name="l01459"></a>01459                             <span class="keywordflow">if</span> (bbeam_dir*beams[bbeam].autoMovingMode &lt;= 0 &amp;&amp; key)
<a name="l01460"></a>01460                             {
<a name="l01461"></a>01461                                 beams[bbeam].autoMovingMode = bbeam_dir*1;
<a name="l01462"></a>01462                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (beams[bbeam].autoMovingMode == bbeam_dir*1 &amp;&amp; !key)
<a name="l01463"></a>01463                             {
<a name="l01464"></a>01464                                 beams[bbeam].autoMovingMode = bbeam_dir*2;
<a name="l01465"></a>01465                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (beams[bbeam].autoMovingMode == bbeam_dir*2 &amp;&amp; key)
<a name="l01466"></a>01466                             {
<a name="l01467"></a>01467                                 beams[bbeam].autoMovingMode = bbeam_dir*3;
<a name="l01468"></a>01468                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (beams[bbeam].autoMovingMode == bbeam_dir*3 &amp;&amp; !key)
<a name="l01469"></a>01469                             {
<a name="l01470"></a>01470                                 beams[bbeam].autoMovingMode = 0;
<a name="l01471"></a>01471                             }
<a name="l01472"></a>01472                         }
<a name="l01473"></a>01473 
<a name="l01474"></a>01474                         <span class="keywordflow">if</span> (cmdInertia)
<a name="l01475"></a>01475                             v = cmdInertia-&gt;calcCmdKeyDelay(v, i, dt);
<a name="l01476"></a>01476 
<a name="l01477"></a>01477                         <span class="keywordflow">if</span> (bbeam_dir*beams[bbeam].autoMovingMode &gt; 0)
<a name="l01478"></a>01478                             v = 1;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480                         <span class="keywordflow">if</span> (beams[bbeam].commandNeedsEngine &amp;&amp; ((engine &amp;&amp; !engine-&gt;running) || !canwork)) <span class="keywordflow">continue</span>;
<a name="l01481"></a>01481 
<a name="l01482"></a>01482                         <span class="keywordflow">if</span> (v &gt; 0.0f &amp;&amp; beams[bbeam].commandEngineCoupling &gt; 0.0f)
<a name="l01483"></a>01483                             requestpower = <span class="keyword">true</span>;
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01486"></a>01486 <span class="preprocessor"></span>                        <span class="comment">// command sounds</span>
<a name="l01487"></a>01487                         <span class="keywordflow">if</span> (vst == 1)
<a name="l01488"></a>01488                         {
<a name="l01489"></a>01489                             <span class="comment">// just started</span>
<a name="l01490"></a>01490                             SoundScriptManager::getSingleton().trigStop(trucknum, SS_TRIG_LINKED_COMMAND, SL_COMMAND, -i);
<a name="l01491"></a>01491                             SoundScriptManager::getSingleton().trigStart(trucknum, SS_TRIG_LINKED_COMMAND, SL_COMMAND, i);
<a name="l01492"></a>01492                             vst = 0;
<a name="l01493"></a>01493                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vst == -1)
<a name="l01494"></a>01494                         {
<a name="l01495"></a>01495                             <span class="comment">// just stopped</span>
<a name="l01496"></a>01496                             SoundScriptManager::getSingleton().trigStop(trucknum, SS_TRIG_LINKED_COMMAND, SL_COMMAND, i);
<a name="l01497"></a>01497                             vst = 0;
<a name="l01498"></a>01498                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vst == 0)
<a name="l01499"></a>01499                         {
<a name="l01500"></a>01500                             <span class="comment">// already running, modulate</span>
<a name="l01501"></a>01501                             SoundScriptManager::getSingleton().modulate(trucknum, SS_MOD_LINKED_COMMANDRATE, v, SL_COMMAND, i);
<a name="l01502"></a>01502                         }
<a name="l01503"></a>01503 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l01504"></a>01504 <span class="preprocessor"></span>                        <span class="keywordtype">float</span> cf = 1.0f;
<a name="l01505"></a>01505 
<a name="l01506"></a>01506                         <span class="keywordflow">if</span> (beams[bbeam].commandEngineCoupling &gt; 0)
<a name="l01507"></a>01507                             cf = crankfactor;
<a name="l01508"></a>01508 
<a name="l01509"></a>01509                         <span class="keywordflow">if</span> (bbeam_dir &gt; 0)
<a name="l01510"></a>01510                             beams[bbeam].L *= (1.0 + beams[bbeam].commandRatioLong * v * cf * dt / beams[bbeam].L);
<a name="l01511"></a>01511                         <span class="keywordflow">else</span>
<a name="l01512"></a>01512                             beams[bbeam].L *= (1.0 - beams[bbeam].commandRatioShort * v * cf * dt / beams[bbeam].L);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514                         dl = fabs(dl - beams[bbeam].L);
<a name="l01515"></a>01515                         <span class="keywordflow">if</span> (requestpower)
<a name="l01516"></a>01516                         {
<a name="l01517"></a>01517                             active++;
<a name="l01518"></a>01518                             work += fabs(beams[bbeam].stress) * dl * beams[bbeam].commandEngineCoupling;
<a name="l01519"></a>01519                         }
<a name="l01520"></a>01520                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (beams[bbeam].isOnePressMode &gt; 0 &amp;&amp; bbeam_dir*beams[bbeam].autoMovingMode &gt; 0)
<a name="l01521"></a>01521                     {
<a name="l01522"></a>01522                         <span class="comment">// beyond length</span>
<a name="l01523"></a>01523                         beams[bbeam].autoMovingMode = 0;
<a name="l01524"></a>01524                     }
<a name="l01525"></a>01525                 }
<a name="l01526"></a>01526             }
<a name="l01527"></a>01527             <span class="comment">// also for rotators</span>
<a name="l01528"></a>01528             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; (int)commandkey[i].rotators.size(); j++)
<a name="l01529"></a>01529             {
<a name="l01530"></a>01530                 <span class="keywordtype">float</span> v = 0.0f;
<a name="l01531"></a>01531                 <span class="keywordtype">int</span> rota = std::abs(commandkey[i].rotators[j]) - 1;
<a name="l01532"></a>01532 
<a name="l01533"></a>01533                 <span class="keywordflow">if</span> (rotators[rota].rotatorNeedsEngine &amp;&amp; ((engine &amp;&amp; !engine-&gt;running) || !canwork)) <span class="keywordflow">continue</span>;
<a name="l01534"></a>01534 
<a name="l01535"></a>01535                 <span class="keywordflow">if</span> (rotaInertia)
<a name="l01536"></a>01536                 {
<a name="l01537"></a>01537                     v = rotaInertia-&gt;calcCmdKeyDelay(commandkey[i].commandValue, i, dt);
<a name="l01538"></a>01538 
<a name="l01539"></a>01539                     <span class="keywordflow">if</span> (v &gt; 0.0f &amp;&amp; rotators[rota].rotatorEngineCoupling &gt; 0.0f)
<a name="l01540"></a>01540                         requestpower = <span class="keyword">true</span>;
<a name="l01541"></a>01541                 }
<a name="l01542"></a>01542 
<a name="l01543"></a>01543                 <span class="keywordtype">float</span> cf = 1.0f;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545                 <span class="keywordflow">if</span> (rotators[rota].rotatorEngineCoupling &gt; 0.0f)
<a name="l01546"></a>01546                     cf = crankfactor;
<a name="l01547"></a>01547 
<a name="l01548"></a>01548                 <span class="keywordflow">if</span> (commandkey[i].rotators[j] &gt; 0)
<a name="l01549"></a>01549                     rotators[rota].angle += rotators[rota].rate * v * cf * dt;
<a name="l01550"></a>01550                 <span class="keywordflow">else</span>
<a name="l01551"></a>01551                     rotators[rota].angle -= rotators[rota].rate * v * cf * dt;
<a name="l01552"></a>01552             }
<a name="l01553"></a>01553             <span class="keywordflow">if</span> (requestpower)
<a name="l01554"></a>01554                 requested++;
<a name="l01555"></a>01555         }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557         <span class="keywordflow">if</span> (engine)
<a name="l01558"></a>01558         {
<a name="l01559"></a>01559             engine-&gt;hydropump = work;
<a name="l01560"></a>01560             engine-&gt;prime     = requested;
<a name="l01561"></a>01561         }
<a name="l01562"></a>01562         <span class="keywordflow">if</span> (doUpdate &amp;&amp; state==<a class="code" href="_beam_data_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a84b328a7ebdea4c8c4ed62e035ada28d" title="leading truck">ACTIVATED</a>)
<a name="l01563"></a>01563         {
<a name="l01564"></a>01564 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01565"></a>01565 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (active &gt; 0)
<a name="l01566"></a>01566             {
<a name="l01567"></a>01567                 SoundScriptManager::getSingleton().trigStart(trucknum, SS_TRIG_PUMP);
<a name="l01568"></a>01568                 <span class="keywordtype">float</span> pump_rpm = 660.0f * (1.0f - (work / (float)active) / 100.0f);
<a name="l01569"></a>01569                 SoundScriptManager::getSingleton().modulate(trucknum, SS_MOD_PUMP, pump_rpm);
<a name="l01570"></a>01570             } <span class="keywordflow">else</span>
<a name="l01571"></a>01571             {
<a name="l01572"></a>01572                 SoundScriptManager::getSingleton().trigStop(trucknum, SS_TRIG_PUMP);
<a name="l01573"></a>01573             }
<a name="l01574"></a>01574 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l01575"></a>01575 <span class="preprocessor"></span>        }
<a name="l01576"></a>01576         <span class="comment">// rotators</span>
<a name="l01577"></a>01577         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_rotator; i++)
<a name="l01578"></a>01578         {
<a name="l01579"></a>01579             <span class="comment">// compute rotation axis</span>
<a name="l01580"></a>01580             <a class="code" href="struct_vector3.html">Vector3</a> axis=nodes[rotators[i].axis1].RelPosition-nodes[rotators[i].axis2].RelPosition;
<a name="l01581"></a>01581             <span class="comment">//axis.normalise();</span>
<a name="l01582"></a>01582             axis=<a class="code" href="_approx_math_8h.html#a88cab057c9c3a7a5cbaa1aebb06bf864">fast_normalise</a>(axis);
<a name="l01583"></a>01583             <span class="comment">// find the reference plane</span>
<a name="l01584"></a>01584             Plane pl=Plane(axis, 0);
<a name="l01585"></a>01585             <span class="comment">// for each pair</span>
<a name="l01586"></a>01586             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;2; k++)
<a name="l01587"></a>01587             {
<a name="l01588"></a>01588                 <span class="comment">// find the reference vectors</span>
<a name="l01589"></a>01589                 <a class="code" href="struct_vector3.html">Vector3</a> ref1=pl.projectVector(nodes[rotators[i].axis2].RelPosition-nodes[rotators[i].nodes1[k]].RelPosition);
<a name="l01590"></a>01590                 <a class="code" href="struct_vector3.html">Vector3</a> ref2=pl.projectVector(nodes[rotators[i].axis2].RelPosition-nodes[rotators[i].nodes2[k]].RelPosition);
<a name="l01591"></a>01591                 <span class="comment">// theory vector</span>
<a name="l01592"></a>01592                 <a class="code" href="struct_vector3.html">Vector3</a> th1=Quaternion(Radian(rotators[i].angle+3.14159/2.0), axis)*ref1;
<a name="l01593"></a>01593                 <span class="comment">// find the angle error</span>
<a name="l01594"></a>01594                 <span class="keywordtype">float</span> aerror=asin((th1.normalisedCopy()).dotProduct(ref2.normalisedCopy()));
<a name="l01595"></a>01595                 <span class="comment">//mWindow-&gt;setDebugText(&quot;Error:&quot;+ TOSTRING(aerror));</span>
<a name="l01596"></a>01596                 <span class="comment">// exert forces</span>
<a name="l01597"></a>01597                 <span class="keywordtype">float</span> rigidity=rotators[i].force;
<a name="l01598"></a>01598                 <a class="code" href="struct_vector3.html">Vector3</a> dir1=ref1.crossProduct(axis);
<a name="l01599"></a>01599                 <span class="comment">//dir1.normalise();</span>
<a name="l01600"></a>01600                 dir1=<a class="code" href="_approx_math_8h.html#a88cab057c9c3a7a5cbaa1aebb06bf864">fast_normalise</a>(dir1);
<a name="l01601"></a>01601                 <a class="code" href="struct_vector3.html">Vector3</a> dir2=ref2.crossProduct(axis);
<a name="l01602"></a>01602                 <span class="comment">//dir2.normalise();</span>
<a name="l01603"></a>01603                 dir2=<a class="code" href="_approx_math_8h.html#a88cab057c9c3a7a5cbaa1aebb06bf864">fast_normalise</a>(dir2);
<a name="l01604"></a>01604                 <span class="keywordtype">float</span> ref1len=ref1.<a class="code" href="struct_vector3.html#a30db3d517cb422cb78a4be0cf52bc89e">length</a>();
<a name="l01605"></a>01605                 <span class="keywordtype">float</span> ref2len=ref2.<a class="code" href="struct_vector3.html#a30db3d517cb422cb78a4be0cf52bc89e">length</a>();
<a name="l01606"></a>01606 
<a name="l01607"></a>01607                 <span class="comment">// simple jitter fix</span>
<a name="l01608"></a>01608                 <span class="keywordflow">if</span> (ref1len &lt;= rotators[i].tolerance) ref1len = 0.0f;
<a name="l01609"></a>01609                 <span class="keywordflow">if</span> (ref2len &lt;= rotators[i].tolerance) ref2len = 0.0f;
<a name="l01610"></a>01610 
<a name="l01611"></a>01611                 nodes[rotators[i].nodes1[k]].Forces+=(aerror*ref1len*rigidity)*dir1;
<a name="l01612"></a>01612                 nodes[rotators[i].nodes2[k]].Forces-=(aerror*ref2len*rigidity)*dir2;
<a name="l01613"></a>01613                 <span class="comment">// symmetric</span>
<a name="l01614"></a>01614                 nodes[rotators[i].nodes1[k+2]].Forces-=(aerror*ref1len*rigidity)*dir1;
<a name="l01615"></a>01615                 nodes[rotators[i].nodes2[k+2]].Forces+=(aerror*ref2len*rigidity)*dir2;
<a name="l01616"></a>01616             }
<a name="l01617"></a>01617         }
<a name="l01618"></a>01618     }
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Commands);    
<a name="l01621"></a>01621 }
<a name="l01622"></a>01622 
<a name="l01623"></a><a class="code" href="class_beam.html#ae334c1e4d96e435806a0fe2067df1dfa">01623</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#ae334c1e4d96e435806a0fe2067df1dfa">Beam::calcReplay</a>(<span class="keywordtype">bool</span> doUpdate, Ogre::Real dt)
<a name="l01624"></a>01624 {
<a name="l01625"></a>01625     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Replay);
<a name="l01626"></a>01626 
<a name="l01627"></a>01627     <span class="comment">// we also store a new replay frame</span>
<a name="l01628"></a>01628     <span class="keywordflow">if</span> (replay &amp;&amp; replay-&gt;isValid())
<a name="l01629"></a>01629     {
<a name="l01630"></a>01630         replayTimer += dt;
<a name="l01631"></a>01631         <span class="keywordflow">if</span> (replayTimer &gt; replayPrecision)
<a name="l01632"></a>01632         {
<a name="l01633"></a>01633             <span class="comment">// store nodes</span>
<a name="l01634"></a>01634             <a class="code" href="structnode__simple__.html">node_simple_t</a> *nbuff = (<a class="code" href="structnode__simple__.html">node_simple_t</a> *)replay-&gt;getWriteBuffer(0);
<a name="l01635"></a>01635             <span class="keywordflow">if</span> (nbuff)
<a name="l01636"></a>01636             {
<a name="l01637"></a>01637                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_node; i++)
<a name="l01638"></a>01638                     nbuff[i].pos = nodes[i].AbsPosition;
<a name="l01639"></a>01639 
<a name="l01640"></a>01640                 <span class="comment">// store beams</span>
<a name="l01641"></a>01641                 <a class="code" href="structbeam__simple__.html">beam_simple_t</a> *bbuff = (<a class="code" href="structbeam__simple__.html">beam_simple_t</a> *)replay-&gt;getWriteBuffer(1);
<a name="l01642"></a>01642                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_beam; i++)
<a name="l01643"></a>01643                 {
<a name="l01644"></a>01644                     bbuff[i].<a class="code" href="structbeam__simple__.html#ad6a7114a421f0c5e0a5e484f052545cb">scale</a> = beams[i].scale;
<a name="l01645"></a>01645                     bbuff[i].<a class="code" href="structbeam__simple__.html#ae7fe846f6f66004b01a94ed34ff51f9f">broken</a> = beams[i].broken;
<a name="l01646"></a>01646                     bbuff[i].<a class="code" href="structbeam__simple__.html#a561820e9258cb0a9dee2b25572d9f1f6">disabled</a> = beams[i].disabled;
<a name="l01647"></a>01647                 }
<a name="l01648"></a>01648 
<a name="l01649"></a>01649                 replay-&gt;writeDone();
<a name="l01650"></a>01650                 replayTimer = 0.0f;
<a name="l01651"></a>01651             }
<a name="l01652"></a>01652         }
<a name="l01653"></a>01653     }
<a name="l01654"></a>01654 
<a name="l01655"></a>01655     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Replay);
<a name="l01656"></a>01656 }
<a name="l01657"></a>01657 
<a name="l01658"></a><a class="code" href="class_beam.html#a35c3767a33cec26ba297d88022c7757c">01658</a> <span class="keywordtype">bool</span> <a class="code" href="class_beam.html#a35c3767a33cec26ba297d88022c7757c" title="physic related functions">Beam::calcForcesEulerPrepare</a>(<span class="keywordtype">int</span> doUpdate, Ogre::Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps)
<a name="l01659"></a>01659 {
<a name="l01660"></a>01660     <span class="keywordflow">if</span> (dt==0.0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01661"></a>01661     <span class="keywordflow">if</span> (state &gt;= <a class="code" href="_beam_data_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a488282601451a751e0f0e770b15d4235" title="not active, sleeping">SLEEPING</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01662"></a>01662     <span class="keywordflow">if</span> (deleting) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01663"></a>01663     <span class="keywordflow">if</span> (reset_requested) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_WholeTruckCalc);
<a name="l01666"></a>01666 
<a name="l01667"></a>01667     forwardCommands();
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 <span class="preprocessor">#if !BEAMS_INTER_TRUCK_PARALLEL</span>
<a name="l01670"></a>01670 <span class="preprocessor"></span><span class="preprocessor">#if !BEAMS_INTRA_TRUCK_PARALLEL</span>
<a name="l01671"></a>01671 <span class="preprocessor"></span>    calcBeams(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l01672"></a>01672 <span class="preprocessor">#else</span>
<a name="l01673"></a>01673 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (free_beam &lt; 100)
<a name="l01674"></a>01674     {
<a name="l01675"></a>01675         calcBeams(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l01676"></a>01676     } <span class="keywordflow">else</span>
<a name="l01677"></a>01677     {
<a name="l01678"></a>01678         runThreadTask(<span class="keyword">this</span>, THREAD_BEAMS, <span class="keyword">true</span>);
<a name="l01679"></a>01679     }
<a name="l01680"></a>01680 <span class="preprocessor">#endif</span>
<a name="l01681"></a>01681 <span class="preprocessor"></span>
<a name="l01682"></a>01682     <span class="keywordflow">if</span> (doUpdate)
<a name="l01683"></a>01683     {
<a name="l01684"></a>01684         <span class="comment">//just call this once per frame to avoid performance impact</span>
<a name="l01685"></a>01685         hookToggle(-2, <a class="code" href="_beam_data_8h.html#a59960ab4d65cd4767a327f24976651cba458a88d526512a61401a9dafcc61b53b">HOOK_LOCK</a>, -1);
<a name="l01686"></a>01686     }
<a name="l01687"></a>01687 <span class="preprocessor">#endif</span>
<a name="l01688"></a>01688 <span class="preprocessor"></span>
<a name="l01689"></a>01689 <span class="preprocessor">#if !NODES_INTER_TRUCK_PARALLEL</span>
<a name="l01690"></a>01690 <span class="preprocessor"></span>    <span class="comment">// START Slidenode section /////////////////////////////////////////////////</span>
<a name="l01691"></a>01691     <span class="comment">// these must be done before the integrator, or else the forces are not calculated properly</span>
<a name="l01692"></a>01692     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_SlideNodes);
<a name="l01693"></a>01693     updateSlideNodeForces(dt);
<a name="l01694"></a>01694     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_SlideNodes);
<a name="l01695"></a>01695     <span class="comment">// END Slidenode section   /////////////////////////////////////////////////</span>
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Nodes);
<a name="l01698"></a>01698 
<a name="l01699"></a>01699     Ogre::AxisAlignedBox tBoundingBox(nodes[0].AbsPosition.x, nodes[0].AbsPosition.y, nodes[0].AbsPosition.z, nodes[0].AbsPosition.x, nodes[0].AbsPosition.y, nodes[0].AbsPosition.z);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; collisionBoundingBoxes.size(); i++)
<a name="l01702"></a>01702     {
<a name="l01703"></a>01703         collisionBoundingBoxes[i].scale(Ogre::Vector3(0.0));
<a name="l01704"></a>01704     }
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     watercontact = <span class="keyword">false</span>;
<a name="l01707"></a>01707 
<a name="l01708"></a>01708 <span class="preprocessor">    #if !NODES_INTRA_TRUCK_PARALLEL</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>        calcNodes(doUpdate, dt, step, maxsteps, 0, 1);
<a name="l01710"></a>01710 <span class="preprocessor">    #else</span>
<a name="l01711"></a>01711 <span class="preprocessor"></span>        runThreadTask(<span class="keyword">this</span>, THREAD_NODES, <span class="keyword">true</span>);
<a name="l01712"></a>01712 <span class="preprocessor">    #endif</span>
<a name="l01713"></a>01713 <span class="preprocessor"></span>
<a name="l01714"></a>01714     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_node; i++)
<a name="l01715"></a>01715     {
<a name="l01716"></a>01716         tBoundingBox.merge(nodes[i].AbsPosition);
<a name="l01717"></a>01717         <span class="keywordflow">if</span> (nodes[i].collisionBoundingBoxID &gt;= 0 &amp;&amp; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) nodes[i].collisionBoundingBoxID &lt; collisionBoundingBoxes.size())
<a name="l01718"></a>01718         {
<a name="l01719"></a>01719             <span class="keywordflow">if</span> (collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].getSize().length() == 0.0 &amp;&amp; collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].getMinimum().length() == 0.0)
<a name="l01720"></a>01720             {
<a name="l01721"></a>01721                 collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].setExtents(nodes[i].AbsPosition.x, nodes[i].AbsPosition.y, nodes[i].AbsPosition.z, nodes[i].AbsPosition.x, nodes[i].AbsPosition.y, nodes[i].AbsPosition.z);
<a name="l01722"></a>01722             } <span class="keywordflow">else</span>
<a name="l01723"></a>01723             {
<a name="l01724"></a>01724                 collisionBoundingBoxes[nodes[i].collisionBoundingBoxID].merge(nodes[i].AbsPosition);
<a name="l01725"></a>01725             }
<a name="l01726"></a>01726         }
<a name="l01727"></a>01727     }
<a name="l01728"></a>01728 
<a name="l01729"></a>01729     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; collisionBoundingBoxes.size(); i++)
<a name="l01730"></a>01730     {
<a name="l01731"></a>01731         collisionBoundingBoxes[i].setMinimum(collisionBoundingBoxes[i].getMinimum() - <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l01732"></a>01732         collisionBoundingBoxes[i].setMaximum(collisionBoundingBoxes[i].getMaximum() + <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l01733"></a>01733 
<a name="l01734"></a>01734         predictedCollisionBoundingBoxes[i].setExtents(collisionBoundingBoxes[i].getMinimum(), collisionBoundingBoxes[i].getMaximum());
<a name="l01735"></a>01735         predictedCollisionBoundingBoxes[i].merge(collisionBoundingBoxes[i].getMinimum() + nodes[0].Velocity * dt);
<a name="l01736"></a>01736         predictedCollisionBoundingBoxes[i].merge(collisionBoundingBoxes[i].getMaximum() + nodes[0].Velocity * dt);
<a name="l01737"></a>01737     }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739     <span class="comment">// anti-explosion guard</span>
<a name="l01740"></a>01740     <span class="comment">// rationale behind 1e9 number:</span>
<a name="l01741"></a>01741     <span class="comment">// - while 1e6 is reachable by a fast vehicle, it will be badly deformed and shaking due to loss of precision in calculations</span>
<a name="l01742"></a>01742     <span class="comment">// - at 1e7 any typical RoR vehicle falls apart and stops functioning</span>
<a name="l01743"></a>01743     <span class="comment">// - 1e9 may be reachable only by a vehicle that is 1000 times bigger than a typical RoR vehicle, and it will be a loooong trip</span>
<a name="l01744"></a>01744     <span class="comment">// to be able to travel such long distances will require switching physics calculations to higher precision numbers</span>
<a name="l01745"></a>01745     <span class="comment">// or taking a different approach to the simulation (truck-local coordinate system?)</span>
<a name="l01746"></a>01746     <span class="keywordflow">if</span> (!inRange(tBoundingBox.getMinimum().x + tBoundingBox.getMaximum().x +
<a name="l01747"></a>01747         tBoundingBox.getMinimum().y + tBoundingBox.getMaximum().y +
<a name="l01748"></a>01748         tBoundingBox.getMinimum().z + tBoundingBox.getMaximum().z, -1e9, 1e9))
<a name="l01749"></a>01749     {
<a name="l01750"></a>01750         reset_requested = 1; <span class="comment">// truck exploded, schedule reset</span>
<a name="l01751"></a>01751         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// return early to avoid propagating invalid values</span>
<a name="l01752"></a>01752     }
<a name="l01753"></a>01753 
<a name="l01754"></a>01754     boundingBox.setMinimum(tBoundingBox.getMinimum() - <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l01755"></a>01755     boundingBox.setMaximum(tBoundingBox.getMaximum() + <a class="code" href="struct_vector3.html">Vector3</a>(0.05f, 0.05f, 0.05f));
<a name="l01756"></a>01756 
<a name="l01757"></a>01757     predictedBoundingBox.setExtents(boundingBox.getMinimum(), boundingBox.getMaximum());
<a name="l01758"></a>01758     predictedBoundingBox.merge(boundingBox.getMinimum() + nodes[0].Velocity * dt);
<a name="l01759"></a>01759     predictedBoundingBox.merge(boundingBox.getMaximum() + nodes[0].Velocity * dt);
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Nodes);
<a name="l01762"></a>01762 <span class="preprocessor">#endif</span>
<a name="l01763"></a>01763 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01764"></a>01764 }
<a name="l01765"></a>01765 
<a name="l01766"></a><a class="code" href="class_beam.html#a0ec96a72537e15007db1ca57898c4ed5">01766</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a0ec96a72537e15007db1ca57898c4ed5">Beam::calcForcesEulerFinal</a>(<span class="keywordtype">int</span> doUpdate, Ogre::Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps)
<a name="l01767"></a>01767 {
<a name="l01768"></a>01768     calcHooks();
<a name="l01769"></a>01769     calcRopes();
<a name="l01770"></a>01770     updateSkeletonColouring(doUpdate);
<a name="l01771"></a>01771 
<a name="l01772"></a>01772     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_WholeTruckCalc);
<a name="l01773"></a>01773 }
<a name="l01774"></a>01774 
<a name="l01775"></a><a class="code" href="class_beam.html#a154c3ab455a74d7e57ef2877c1eaf9f9">01775</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#aec1d802b1efee85ebaa13a6e9dccf036">Beam::calcBeams</a>(<span class="keywordtype">int</span> doUpdate, Ogre::Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps, <span class="keywordtype">int</span> chunk_index, <span class="keywordtype">int</span> chunk_number)
<a name="l01776"></a>01776 {
<a name="l01777"></a>01777     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Beams);
<a name="l01778"></a>01778     <span class="comment">// Springs</span>
<a name="l01779"></a>01779     <span class="keywordtype">int</span> chunk_size = free_beam / chunk_number;
<a name="l01780"></a>01780     <span class="keywordtype">int</span> end_index = (chunk_index+1)*chunk_size;
<a name="l01781"></a>01781 
<a name="l01782"></a>01782     <span class="keywordflow">if</span> (chunk_index+1 == chunk_number)
<a name="l01783"></a>01783     {
<a name="l01784"></a>01784         end_index = free_beam;
<a name="l01785"></a>01785     }
<a name="l01786"></a>01786 
<a name="l01787"></a>01787     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=chunk_index*chunk_size; i&lt;end_index; i++)
<a name="l01788"></a>01788     {
<a name="l01789"></a>01789         <a class="code" href="struct_vector3.html">Vector3</a> dis(Vector3::ZERO);
<a name="l01790"></a>01790         <span class="comment">// Trick for exploding stuff</span>
<a name="l01791"></a>01791         <span class="keywordflow">if</span> (!beams[i].disabled)
<a name="l01792"></a>01792         {
<a name="l01793"></a>01793             <span class="comment">// Calculate beam length</span>
<a name="l01794"></a>01794             <span class="keywordflow">if</span> (!beams[i].p2truck)
<a name="l01795"></a>01795                 dis = beams[i].p1-&gt;RelPosition - beams[i].p2-&gt;RelPosition;
<a name="l01796"></a>01796             <span class="keywordflow">else</span>
<a name="l01797"></a>01797                 dis = beams[i].p1-&gt;AbsPosition - beams[i].p2-&gt;AbsPosition;
<a name="l01798"></a>01798 
<a name="l01799"></a>01799             Real dislen = dis.squaredLength();
<a name="l01800"></a>01800             Real inverted_dislen = <a class="code" href="_approx_math_8h.html#a08e9e14c091640464aae072f3823b855">fast_invSqrt</a>(dislen);
<a name="l01801"></a>01801             
<a name="l01802"></a>01802             dislen *= inverted_dislen;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804             <span class="comment">// Calculate beam&#39;s deviation from normal</span>
<a name="l01805"></a>01805             Real difftoBeamL = dislen - beams[i].L;
<a name="l01806"></a>01806 
<a name="l01807"></a>01807             Real k = beams[i].k;
<a name="l01808"></a>01808             Real d = beams[i].d;
<a name="l01809"></a>01809 
<a name="l01810"></a>01810             <span class="keywordflow">switch</span> (beams[i].bounded)
<a name="l01811"></a>01811             {
<a name="l01812"></a>01812             <span class="keywordflow">case</span> <a class="code" href="_beam_data_8h.html#aabfcbcb5ac86a1edac4035264bc7d2b8a529ecdf951f828a68dac101249641a58" title="shock1">SHOCK1</a>:
<a name="l01813"></a>01813                 {
<a name="l01814"></a>01814                     <span class="keywordtype">float</span> interp_ratio;
<a name="l01815"></a>01815 
<a name="l01816"></a>01816                     <span class="comment">// Following code interpolates between defined beam parameters and default beam parameters</span>
<a name="l01817"></a>01817                     <span class="keywordflow">if</span> (difftoBeamL &gt; beams[i].longbound * beams[i].L)
<a name="l01818"></a>01818                         interp_ratio =  difftoBeamL - beams[i].longbound  * beams[i].L;
<a name="l01819"></a>01819                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (difftoBeamL &lt; -beams[i].shortbound * beams[i].L)
<a name="l01820"></a>01820                         interp_ratio = -difftoBeamL - beams[i].shortbound * beams[i].L;
<a name="l01821"></a>01821                     <span class="keywordflow">else</span>
<a name="l01822"></a>01822                         <span class="keywordflow">break</span>;
<a name="l01823"></a>01823 
<a name="l01824"></a>01824                     <span class="comment">// Hard (normal) shock bump</span>
<a name="l01825"></a>01825                     <span class="keywordtype">float</span> tspring = <a class="code" href="_beam_data_8h.html#a049040ae0d86d8d3abce13f440368090">DEFAULT_SPRING</a>;
<a name="l01826"></a>01826                     <span class="keywordtype">float</span> tdamp   = <a class="code" href="_beam_data_8h.html#a657ea8af8ce20bb2abb77320e89d5917">DEFAULT_DAMP</a>;
<a name="l01827"></a>01827 
<a name="l01828"></a>01828                     <span class="comment">// Skip camera, wheels or any other shocks which are not generated in a shocks or shocks2 section</span>
<a name="l01829"></a>01829                     <span class="keywordflow">if</span> (beams[i].type == <a class="code" href="_beam_data_8h.html#aae05225933a42f81e7c4a9fb286596f9ab522c320ea8aec4b2c603a232c1358bf">BEAM_HYDRO</a> || beams[i].type == <a class="code" href="_beam_data_8h.html#aae05225933a42f81e7c4a9fb286596f9a5be34e9e01ae386fa307a3aa737cb42f">BEAM_INVISIBLE_HYDRO</a>)
<a name="l01830"></a>01830                     {
<a name="l01831"></a>01831                         tspring = beams[i].shock-&gt;sbd_spring;
<a name="l01832"></a>01832                         tdamp   = beams[i].shock-&gt;sbd_damp;
<a name="l01833"></a>01833                     }
<a name="l01834"></a>01834 
<a name="l01835"></a>01835                     k += (tspring - k) * interp_ratio;
<a name="l01836"></a>01836                     d += (tdamp   - d) * interp_ratio;
<a name="l01837"></a>01837                 }
<a name="l01838"></a>01838                 <span class="keywordflow">break</span>;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840             <span class="keywordflow">case</span> <a class="code" href="_beam_data_8h.html#aabfcbcb5ac86a1edac4035264bc7d2b8a696845de03029f4206a9af01e8c13c69" title="shock2">SHOCK2</a>:
<a name="l01841"></a>01841                 calcShocks2(i, difftoBeamL, k, d, dt, doUpdate);
<a name="l01842"></a>01842                 <span class="keywordflow">break</span>;
<a name="l01843"></a>01843 
<a name="l01844"></a>01844             <span class="keywordflow">case</span> <a class="code" href="_beam_data_8h.html#aabfcbcb5ac86a1edac4035264bc7d2b8a72a34d3462a4be2ed9be16dff42f78d2">SUPPORTBEAM</a>:
<a name="l01845"></a>01845                 <span class="keywordflow">if</span> (difftoBeamL &gt; 0.0f)
<a name="l01846"></a>01846                 {
<a name="l01847"></a>01847                     k  = 0.0f;
<a name="l01848"></a>01848                     d *= 0.1f;
<a name="l01849"></a>01849                     <span class="keywordtype">float</span> break_limit = <a class="code" href="_beam_data_8h.html#aa87f44a8296308cb9e857fe38ac863b0">SUPPORT_BEAM_LIMIT_DEFAULT</a>;
<a name="l01850"></a>01850                     <span class="keywordflow">if</span> (beams[i].longbound &gt; 0.0f)
<a name="l01851"></a>01851                     {
<a name="l01852"></a>01852                         <span class="comment">// This is a supportbeam with a user set break limit, get the user set limit</span>
<a name="l01853"></a>01853                         break_limit = beams[i].longbound;
<a name="l01854"></a>01854                     }
<a name="l01855"></a>01855 
<a name="l01856"></a>01856                     <span class="comment">// If support beam is extended the originallength * break_limit, break and disable it</span>
<a name="l01857"></a>01857                     <span class="keywordflow">if</span> (difftoBeamL &gt; beams[i].L * break_limit)
<a name="l01858"></a>01858                     {
<a name="l01859"></a>01859                         beams[i].broken = <span class="keyword">true</span>;
<a name="l01860"></a>01860                         beams[i].disabled = <span class="keyword">true</span>;
<a name="l01861"></a>01861                         <span class="keywordflow">if</span> (beambreakdebug)
<a name="l01862"></a>01862                         {
<a name="l01863"></a>01863                             <a class="code" href="_ro_r_prerequisites_8h.html#af855c94dc540e943632089ce7496faac">LOG</a>(<span class="stringliteral">&quot; XXX Support-Beam &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(i) + <span class="stringliteral">&quot; limit extended and broke. Length: &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(difftoBeamL) + <span class="stringliteral">&quot; / max. Length: &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].L*break_limit) + <span class="stringliteral">&quot;. It was between nodes &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].p1-&gt;id) + <span class="stringliteral">&quot; and &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].p2-&gt;id) + <span class="stringliteral">&quot;.&quot;</span>);
<a name="l01864"></a>01864                         }
<a name="l01865"></a>01865                     }
<a name="l01866"></a>01866                 }
<a name="l01867"></a>01867                 <span class="keywordflow">break</span>;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869             <span class="keywordflow">case</span> <a class="code" href="_beam_data_8h.html#aabfcbcb5ac86a1edac4035264bc7d2b8a24d6f5addc374131ab07a16c222d6992">ROPE</a>:
<a name="l01870"></a>01870                 <span class="keywordflow">if</span> (difftoBeamL &lt; 0.0f)
<a name="l01871"></a>01871                 {
<a name="l01872"></a>01872                     k  = 0.0f;
<a name="l01873"></a>01873                     d *= 0.1f;
<a name="l01874"></a>01874                 }
<a name="l01875"></a>01875                 <span class="keywordflow">break</span>;
<a name="l01876"></a>01876             }
<a name="l01877"></a>01877 
<a name="l01878"></a>01878             <span class="comment">// Calculate beam&#39;s rate of change</span>
<a name="l01879"></a>01879             <a class="code" href="struct_vector3.html">Vector3</a> v = beams[i].p1-&gt;Velocity - beams[i].p2-&gt;Velocity;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881             <span class="keywordtype">float</span> slen = -k * (difftoBeamL) - d * v.dotProduct(dis) * inverted_dislen;
<a name="l01882"></a>01882             beams[i].stress = slen;
<a name="l01883"></a>01883             <span class="keywordtype">float</span> len = std::abs(slen);
<a name="l01884"></a>01884             
<a name="l01885"></a>01885 
<a name="l01886"></a>01886             <span class="comment">// Fast test for deformation</span>
<a name="l01887"></a>01887             <span class="keywordflow">if</span> (len &gt; beams[i].minmaxposnegstress)
<a name="l01888"></a>01888             {
<a name="l01889"></a>01889                 <span class="keywordflow">if</span> ((beams[i].type==<a class="code" href="_beam_data_8h.html#aae05225933a42f81e7c4a9fb286596f9a83a5f9df360e2e9881e0d15ab979e8a7">BEAM_NORMAL</a> || beams[i].type==<a class="code" href="_beam_data_8h.html#aae05225933a42f81e7c4a9fb286596f9a7acff4517c1614edded0989bf5162652">BEAM_INVISIBLE</a>) &amp;&amp; beams[i].bounded!=<a class="code" href="_beam_data_8h.html#aabfcbcb5ac86a1edac4035264bc7d2b8a529ecdf951f828a68dac101249641a58" title="shock1">SHOCK1</a> &amp;&amp; k!=0.0f)
<a name="l01890"></a>01890                 {
<a name="l01891"></a>01891                     Real deform;
<a name="l01892"></a>01892                     <span class="comment">// Actual deformation tests</span>
<a name="l01893"></a>01893                     <span class="keywordflow">if</span> (slen &gt; beams[i].maxposstress &amp;&amp; difftoBeamL &lt; 0.0f) <span class="comment">// compression</span>
<a name="l01894"></a>01894                     {
<a name="l01895"></a>01895                         increased_accuracy = <span class="keyword">true</span>;
<a name="l01896"></a>01896                         Real yield_length = beams[i].maxposstress / k;
<a name="l01897"></a>01897                         deform = difftoBeamL + yield_length * (1.0f - beams[i].plastic_coef);
<a name="l01898"></a>01898                         Real Lold = beams[i].L;
<a name="l01899"></a>01899                         beams[i].L += deform;
<a name="l01900"></a>01900                         beams[i].L = std::max(<a class="code" href="_beam_data_8h.html#af871c905b09a5c5cb1e6a50f6c7fd6e8" title="minimum beam lenght is 10 centimeters">MIN_BEAM_LENGTH</a>, beams[i].L);
<a name="l01901"></a>01901                         slen = slen - (slen - beams[i].maxposstress) * 0.5f;
<a name="l01902"></a>01902                         len = slen;
<a name="l01903"></a>01903                         <span class="keywordflow">if</span> (beams[i].L &gt; 0.0f &amp;&amp; Lold &gt; beams[i].L)
<a name="l01904"></a>01904                         {
<a name="l01905"></a>01905                             beams[i].maxposstress *= Lold / beams[i].L;
<a name="l01906"></a>01906                         }
<a name="l01907"></a>01907                         <span class="comment">// For the compression case we do not remove any of the beam&#39;s</span>
<a name="l01908"></a>01908                         <span class="comment">// strength for structure stability reasons</span>
<a name="l01909"></a>01909                         <span class="comment">//beams[i].strength += deform * k * 0.5f;</span>
<a name="l01910"></a>01910                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (slen &lt; beams[i].maxnegstress &amp;&amp; difftoBeamL &gt; 0.0f) <span class="comment">// expansion</span>
<a name="l01911"></a>01911                     {
<a name="l01912"></a>01912                         increased_accuracy = <span class="keyword">true</span>;
<a name="l01913"></a>01913                         Real yield_length = beams[i].maxnegstress / k;
<a name="l01914"></a>01914                         deform = difftoBeamL + yield_length * (1.0f - beams[i].plastic_coef);
<a name="l01915"></a>01915                         Real Lold = beams[i].L;
<a name="l01916"></a>01916                         beams[i].L += deform;
<a name="l01917"></a>01917                         slen = slen - (slen - beams[i].maxnegstress) * 0.5f;
<a name="l01918"></a>01918                         len = -slen;
<a name="l01919"></a>01919                         <span class="keywordflow">if</span> (Lold &gt; 0.0f &amp;&amp; beams[i].L &gt; Lold)
<a name="l01920"></a>01920                         {
<a name="l01921"></a>01921                             beams[i].maxnegstress *= beams[i].L / Lold;
<a name="l01922"></a>01922                         }
<a name="l01923"></a>01923                         beams[i].strength -= deform * k;
<a name="l01924"></a>01924                     }
<a name="l01925"></a>01925 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01926"></a>01926 <span class="preprocessor"></span>                    <span class="comment">// Sound effect</span>
<a name="l01927"></a>01927                     <span class="comment">// Sound volume depends on the energy lost due to deformation (which gets converted to sound (and thermal) energy)</span>
<a name="l01928"></a>01928                     
<a name="l01929"></a>01929                     SoundScriptManager::getSingleton().modulate(trucknum, SS_MOD_CREAK, deform*k*(difftoBeamL+deform*0.5f));
<a name="l01930"></a>01930                     SoundScriptManager::getSingleton().trigOnce(trucknum, SS_TRIG_CREAK);
<a name="l01931"></a>01931                     
<a name="l01932"></a>01932 <span class="preprocessor">#endif  //USE_OPENAL</span>
<a name="l01933"></a>01933 <span class="preprocessor"></span>                    beams[i].minmaxposnegstress = std::min(beams[i].maxposstress, -beams[i].maxnegstress);
<a name="l01934"></a>01934                     beams[i].minmaxposnegstress = std::min(beams[i].minmaxposnegstress, beams[i].strength);
<a name="l01935"></a>01935                     <span class="keywordflow">if</span> (beamdeformdebug)
<a name="l01936"></a>01936                     {
<a name="l01937"></a>01937                         <a class="code" href="_ro_r_prerequisites_8h.html#af855c94dc540e943632089ce7496faac">LOG</a>(<span class="stringliteral">&quot; YYY Beam &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(i) + <span class="stringliteral">&quot; just deformed with extension force &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(len) + <span class="stringliteral">&quot; / &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].strength) + <span class="stringliteral">&quot;. It was between nodes &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].p1-&gt;id) + <span class="stringliteral">&quot; and &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].p2-&gt;id) + <span class="stringliteral">&quot;.&quot;</span>);
<a name="l01938"></a>01938                     }
<a name="l01939"></a>01939                 }
<a name="l01940"></a>01940 
<a name="l01941"></a>01941                 <span class="comment">// Test if the beam should break</span>
<a name="l01942"></a>01942                 <span class="keywordflow">if</span> (len &gt; beams[i].strength)
<a name="l01943"></a>01943                 {
<a name="l01944"></a>01944                     <span class="comment">// Sound effect.</span>
<a name="l01945"></a>01945                     <span class="comment">// Sound volume depends on springs stored energy</span>
<a name="l01946"></a>01946 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l01947"></a>01947 <span class="preprocessor"></span>                    SoundScriptManager::getSingleton().modulate(trucknum, SS_MOD_BREAK, 0.5*k*difftoBeamL*difftoBeamL);
<a name="l01948"></a>01948                     SoundScriptManager::getSingleton().trigOnce(trucknum, SS_TRIG_BREAK);
<a name="l01949"></a>01949 <span class="preprocessor">#endif //OPENAL</span>
<a name="l01950"></a>01950 <span class="preprocessor"></span>                    increased_accuracy = <span class="keyword">true</span>;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952                     <span class="comment">//Break the beam only when it is not connected to a node</span>
<a name="l01953"></a>01953                     <span class="comment">//which is a part of a collision triangle and has 2 &quot;live&quot; beams or less</span>
<a name="l01954"></a>01954                     <span class="comment">//connected to it.</span>
<a name="l01955"></a>01955                     <span class="keywordflow">if</span> (!((beams[i].p1-&gt;contacter &amp;&amp; nodeBeamConnections(beams[i].p1-&gt;pos)&lt;3) || (beams[i].p2-&gt;contacter &amp;&amp; nodeBeamConnections(beams[i].p2-&gt;pos)&lt;3)))
<a name="l01956"></a>01956                     {
<a name="l01957"></a>01957                         slen = 0.0f;
<a name="l01958"></a>01958                         beams[i].broken     = <span class="keyword">true</span>;
<a name="l01959"></a>01959                         beams[i].disabled   = <span class="keyword">true</span>;
<a name="l01960"></a>01960                         beams[i].p1-&gt;isSkin = <span class="keyword">true</span>;
<a name="l01961"></a>01961                         beams[i].p2-&gt;isSkin = <span class="keyword">true</span>;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963                         <span class="keywordflow">if</span> (beambreakdebug)
<a name="l01964"></a>01964                         {
<a name="l01965"></a>01965                             <a class="code" href="_ro_r_prerequisites_8h.html#af855c94dc540e943632089ce7496faac">LOG</a>(<span class="stringliteral">&quot; XXX Beam &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(i) + <span class="stringliteral">&quot; just broke with force &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(len) + <span class="stringliteral">&quot; / &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].strength) + <span class="stringliteral">&quot;. It was between nodes &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].p1-&gt;id) + <span class="stringliteral">&quot; and &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].p2-&gt;id) + <span class="stringliteral">&quot;.&quot;</span>);
<a name="l01966"></a>01966                         }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968                         <span class="comment">// detachergroup check: beam[i] is already broken, check detacher group# == 0/default skip the check ( performance bypass for beams with default setting )</span>
<a name="l01969"></a>01969                         <span class="comment">// only perform this check if this is a master detacher beams (positive detacher group id &gt; 0)</span>
<a name="l01970"></a>01970                         <span class="keywordflow">if</span> (beams[i].detacher_group &gt; 0)
<a name="l01971"></a>01971                         {
<a name="l01972"></a>01972                             <span class="comment">// cycle once through the other beams</span>
<a name="l01973"></a>01973                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; free_beam; j++)
<a name="l01974"></a>01974                             {
<a name="l01975"></a>01975                                 <span class="comment">// beam[i] detacher group# == checked beams detacher group# -&gt; delete &amp; disable checked beam</span>
<a name="l01976"></a>01976                                 <span class="comment">// do this with all master(positive id) and minor(negative id) beams of this detacher group</span>
<a name="l01977"></a>01977                                 <span class="keywordflow">if</span> (abs(beams[j].detacher_group) == beams[i].detacher_group)
<a name="l01978"></a>01978                                 {
<a name="l01979"></a>01979                                     beams[j].broken     = <span class="keyword">true</span>;
<a name="l01980"></a>01980                                     beams[j].disabled   = <span class="keyword">true</span>;
<a name="l01981"></a>01981                                     beams[j].p1-&gt;isSkin = <span class="keyword">true</span>;
<a name="l01982"></a>01982                                     beams[j].p2-&gt;isSkin = <span class="keyword">true</span>;
<a name="l01983"></a>01983                                     <span class="keywordflow">if</span> (beambreakdebug)
<a name="l01984"></a>01984                                     {
<a name="l01985"></a>01985                                         <a class="code" href="_ro_r_prerequisites_8h.html#af855c94dc540e943632089ce7496faac">LOG</a>(<span class="stringliteral">&quot;Deleting Detacher BeamID: &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(j) + <span class="stringliteral">&quot;, Detacher Group: &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(beams[i].detacher_group)+  <span class="stringliteral">&quot;, trucknum: &quot;</span> + <a class="code" href="_ro_r_prerequisites_8h.html#a9063e80f8777300c93afde6e6f4c9cea">TOSTRING</a>(trucknum));
<a name="l01986"></a>01986                                     }
<a name="l01987"></a>01987                                 }
<a name="l01988"></a>01988                             }
<a name="l01989"></a>01989                         }
<a name="l01990"></a>01990                     } <span class="keywordflow">else</span>
<a name="l01991"></a>01991                     {
<a name="l01992"></a>01992                         beams[i].strength = 2.0f * beams[i].minmaxposnegstress;
<a name="l01993"></a>01993                     }
<a name="l01994"></a>01994 
<a name="l01995"></a>01995                     <span class="comment">// something broke, check buoyant hull</span>
<a name="l01996"></a>01996                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> mk=0; mk&lt;free_buoycab; mk++)
<a name="l01997"></a>01997                     {
<a name="l01998"></a>01998                         <span class="keywordtype">int</span> tmpv = buoycabs[mk] * 3;
<a name="l01999"></a>01999                         <span class="keywordflow">if</span> (buoycabtypes[mk] == <a class="code" href="class_buoyance.html#a344c522c179a49a948a924752d2b6a26a6ef8dc6ac0f201dbcf814ba0f131df66">Buoyance::BUOY_DRAGONLY</a>) <span class="keywordflow">continue</span>;
<a name="l02000"></a>02000                         <span class="keywordflow">if</span> ((beams[i].p1==&amp;nodes[cabs[tmpv]] || beams[i].p1==&amp;nodes[cabs[tmpv+1]] || beams[i].p1==&amp;nodes[cabs[tmpv+2]]) &amp;&amp;
<a name="l02001"></a>02001                             (beams[i].p2==&amp;nodes[cabs[tmpv]] || beams[i].p2==&amp;nodes[cabs[tmpv+1]] || beams[i].p2==&amp;nodes[cabs[tmpv+2]]))
<a name="l02002"></a>02002                         {
<a name="l02003"></a>02003                             buoyance-&gt;setsink(1);
<a name="l02004"></a>02004                         }
<a name="l02005"></a>02005                     }
<a name="l02006"></a>02006                 }
<a name="l02007"></a>02007             }
<a name="l02008"></a>02008 
<a name="l02009"></a>02009             <span class="comment">// At last update the beam forces</span>
<a name="l02010"></a>02010             <a class="code" href="struct_vector3.html">Vector3</a> f = dis;
<a name="l02011"></a>02011             f *= (slen * inverted_dislen);
<a name="l02012"></a>02012             beams[i].p1-&gt;Forces += f;
<a name="l02013"></a>02013             beams[i].p2-&gt;Forces -= f;
<a name="l02014"></a>02014         }
<a name="l02015"></a>02015     }
<a name="l02016"></a>02016     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Beams);
<a name="l02017"></a>02017 }
<a name="l02018"></a>02018 
<a name="l02019"></a><a class="code" href="class_beam.html#a406010888acacc4e279c04312d386d2c">02019</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a406010888acacc4e279c04312d386d2c">Beam::calcNodes</a>(<span class="keywordtype">int</span> doUpdate, Ogre::Real dt, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> maxsteps, <span class="keywordtype">int</span> chunk_index, <span class="keywordtype">int</span> chunk_number)
<a name="l02020"></a>02020 {
<a name="l02021"></a>02021     <a class="code" href="class_i_water.html">IWater</a> *water = 0;
<a name="l02022"></a>02022     <span class="keywordflow">if</span> (<a class="code" href="_main_thread_8cpp.html#aa88203d48340f609e6b6c7f1471f3b8e">gEnv</a>-&gt;<a class="code" href="class_global_environment.html#a23825f69e60897a660d18659399e0de2">terrainManager</a>)
<a name="l02023"></a>02023         water = <a class="code" href="_main_thread_8cpp.html#aa88203d48340f609e6b6c7f1471f3b8e">gEnv</a>-&gt;<a class="code" href="class_global_environment.html#a23825f69e60897a660d18659399e0de2">terrainManager</a>-&gt;<a class="code" href="class_terrain_manager.html#a1d0227a71a4e114099797646ff6756b7">getWater</a>();
<a name="l02024"></a>02024 
<a name="l02025"></a>02025     <span class="keywordtype">int</span> chunk_size = free_node / chunk_number;
<a name="l02026"></a>02026     <span class="keywordtype">int</span> end_index = (chunk_index+1)*chunk_size;
<a name="l02027"></a>02027 
<a name="l02028"></a>02028     <span class="keywordflow">if</span> (chunk_index+1 == chunk_number)
<a name="l02029"></a>02029     {
<a name="l02030"></a>02030         end_index = free_node;
<a name="l02031"></a>02031     }
<a name="l02032"></a>02032 
<a name="l02033"></a>02033     doUpdate = (step == chunk_index * (maxsteps / chunk_number));
<a name="l02034"></a>02034 
<a name="l02035"></a>02035     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=chunk_index*chunk_size; i&lt;end_index; i++)
<a name="l02036"></a>02036     {
<a name="l02037"></a>02037         <span class="comment">//if (_isnan(nodes[i].Position.length())) LOG(&quot;Node is NaN &quot;+TOSTRING(i));</span>
<a name="l02038"></a>02038 
<a name="l02039"></a>02039         <span class="comment">// wetness</span>
<a name="l02040"></a>02040         <span class="keywordflow">if</span> (nodes[i].wetstate==<a class="code" href="_beam_data_8h.html#a7ff5f2dff38e7639981794c43dc9167baad1e429e37dfbd6d68c8dccf300da474" title="node is dripping">DRIPPING</a> &amp;&amp; !nodes[i].contactless &amp;&amp; !nodes[i].disable_particles)
<a name="l02041"></a>02041         {
<a name="l02042"></a>02042             nodes[i].wettime += dt;
<a name="l02043"></a>02043             <span class="keywordflow">if</span> (nodes[i].wettime &gt; 5.0)
<a name="l02044"></a>02044             {
<a name="l02045"></a>02045                 nodes[i].wetstate = <a class="code" href="_beam_data_8h.html#a7ff5f2dff38e7639981794c43dc9167baac846926be1306ef258549902ab00a25" title="node is dry">DRY</a>; <span class="comment">//dry!</span>
<a name="l02046"></a>02046             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (doUpdate)
<a name="l02047"></a>02047             {
<a name="l02048"></a>02048                 <span class="keywordflow">if</span> (!nodes[i].iswheel &amp;&amp; dripp) dripp-&gt;allocDrip(nodes[i].smoothpos, nodes[i].Velocity, nodes[i].wettime);
<a name="l02049"></a>02049                 <span class="comment">//also for hot engine</span>
<a name="l02050"></a>02050                 <span class="keywordflow">if</span> (nodes[i].isHot &amp;&amp; dustp) dustp-&gt;allocVapour(nodes[i].smoothpos, nodes[i].Velocity, nodes[i].wettime);
<a name="l02051"></a>02051             }
<a name="l02052"></a>02052         }
<a name="l02053"></a>02053         <span class="comment">// locked nodes</span>
<a name="l02054"></a>02054         <span class="keywordflow">if</span> (nodes[i].lockednode)
<a name="l02055"></a>02055         {
<a name="l02056"></a>02056             nodes[i].AbsPosition = nodes[i].lockedPosition;
<a name="l02057"></a>02057             nodes[i].RelPosition = nodes[i].lockedPosition-origin;
<a name="l02058"></a>02058             nodes[i].Velocity = nodes[i].lockedVelocity;
<a name="l02059"></a>02059             nodes[i].lockedForces = nodes[i].Forces;
<a name="l02060"></a>02060             nodes[i].Forces = Vector3::ZERO;
<a name="l02061"></a>02061         }
<a name="l02062"></a>02062 
<a name="l02063"></a>02063         <span class="comment">// COLLISION</span>
<a name="l02064"></a>02064         <span class="keywordflow">if</span> (!nodes[i].contactless)
<a name="l02065"></a>02065         {
<a name="l02066"></a>02066             nodes[i].collTestTimer += dt;
<a name="l02067"></a>02067             <span class="keywordflow">if</span> (nodes[i].contacted || nodes[i].collTestTimer&gt;0.005 || (nodes[i].iswheel &amp;&amp; nodes[i].collTestTimer&gt;0.0025) || increased_accuracy)
<a name="l02068"></a>02068             {
<a name="l02069"></a>02069                 <span class="keywordtype">float</span> ns = 0;
<a name="l02070"></a>02070                 <a class="code" href="structground__model__t.html">ground_model_t</a> *gm = 0; <span class="comment">// this is used as result storage, so we can use it later on</span>
<a name="l02071"></a>02071                 <span class="keywordtype">int</span> contacted = 0;
<a name="l02072"></a>02072                 <span class="keywordtype">int</span> handlernum = -1;
<a name="l02073"></a>02073                 <span class="comment">// reverted this construct to the old form, don&#39;t mess with it, the binary operator is intentionally!</span>
<a name="l02074"></a>02074                 <span class="keywordflow">if</span> ((contacted=<a class="code" href="_main_thread_8cpp.html#aa88203d48340f609e6b6c7f1471f3b8e">gEnv</a>-&gt;<a class="code" href="class_global_environment.html#ade116fce13c1146004478e54b19ce5d3">collisions</a>-&gt;<a class="code" href="class_collisions.html#af1028e2b9de09140265d02b66654f78f">groundCollision</a>(&amp;nodes[i], nodes[i].collTestTimer, &amp;gm, &amp;ns)) | <a class="code" href="_main_thread_8cpp.html#aa88203d48340f609e6b6c7f1471f3b8e">gEnv</a>-&gt;<a class="code" href="class_global_environment.html#ade116fce13c1146004478e54b19ce5d3">collisions</a>-&gt;<a class="code" href="class_collisions.html#a7d672022c769ed5db3ea6aaf08117212">nodeCollision</a>(&amp;nodes[i], i==cinecameranodepos[currentcamera], contacted, nodes[i].collTestTimer, &amp;ns, &amp;gm, &amp;handlernum))
<a name="l02075"></a>02075                 {
<a name="l02076"></a>02076                     <span class="comment">// FX</span>
<a name="l02077"></a>02077                     <span class="keywordflow">if</span> (gm &amp;&amp; doUpdate &amp;&amp; !nodes[i].disable_particles)
<a name="l02078"></a>02078                     {
<a name="l02079"></a>02079                         <span class="keywordtype">float</span> thresold = 10.0f;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081                         <span class="keywordflow">switch</span> (gm-&gt;<a class="code" href="structground__model__t.html#ae31efed91780cbfb4a64132844a70734">fx_type</a>)
<a name="l02082"></a>02082                         {
<a name="l02083"></a>02083                         <span class="keywordflow">case</span> <a class="code" href="class_collisions.html#abc67d9eaedcf832c061f5925bdae7964ae4e1f5c321d124ba62e63e9e2294d4d4">Collisions::FX_DUSTY</a>:
<a name="l02084"></a>02084                             <span class="keywordflow">if</span> (dustp) dustp-&gt;malloc(nodes[i].AbsPosition, nodes[i].Velocity/2.0, gm-&gt;<a class="code" href="structground__model__t.html#a2e17d0e8ddc90c1fa2c52d7d36f0b1f2">fx_colour</a>);
<a name="l02085"></a>02085                             <span class="keywordflow">break</span>;
<a name="l02086"></a>02086 
<a name="l02087"></a>02087                         <span class="keywordflow">case</span> <a class="code" href="class_collisions.html#abc67d9eaedcf832c061f5925bdae7964a0f5d1f2e514c983bc896b8e3a163c1fd">Collisions::FX_HARD</a>:
<a name="l02088"></a>02088                             <span class="comment">// smokey</span>
<a name="l02089"></a>02089                             <span class="keywordflow">if</span> (nodes[i].iswheel &amp;&amp; ns &gt; thresold)
<a name="l02090"></a>02090                             {
<a name="l02091"></a>02091                                 <span class="keywordflow">if</span> (dustp) dustp-&gt;allocSmoke(nodes[i].AbsPosition, nodes[i].Velocity);
<a name="l02092"></a>02092 <span class="preprocessor">#ifdef USE_OPENAL</span>
<a name="l02093"></a>02093 <span class="preprocessor"></span>                                SoundScriptManager::getSingleton().modulate(trucknum, SS_MOD_SCREETCH, (ns-thresold) / thresold);
<a name="l02094"></a>02094                                 SoundScriptManager::getSingleton().trigOnce(trucknum, SS_TRIG_SCREETCH);
<a name="l02095"></a>02095 <span class="preprocessor">#endif //USE_OPENAL</span>
<a name="l02096"></a>02096 <span class="preprocessor"></span><span class="comment">//Shouldn&#39;t skidmarks be activated from here?</span>
<a name="l02097"></a>02097                                 <span class="keywordflow">if</span> (useSkidmarks)
<a name="l02098"></a>02098                                 {
<a name="l02099"></a>02099                                     wheels[nodes[i].wheelid].isSkiding = <span class="keyword">true</span>;
<a name="l02100"></a>02100                                     <span class="keywordflow">if</span> (!(nodes[i].iswheel % 2))
<a name="l02101"></a>02101                                         wheels[nodes[i].wheelid].lastContactInner = nodes[i].AbsPosition;
<a name="l02102"></a>02102                                     <span class="keywordflow">else</span>
<a name="l02103"></a>02103                                         wheels[nodes[i].wheelid].lastContactOuter = nodes[i].AbsPosition;
<a name="l02104"></a>02104 
<a name="l02105"></a>02105                                     wheels[nodes[i].wheelid].lastContactType = (nodes[i].iswheel % 2);
<a name="l02106"></a>02106                                     wheels[nodes[i].wheelid].lastSlip = ns;
<a name="l02107"></a>02107                                     wheels[nodes[i].wheelid].lastGroundModel = gm;
<a name="l02108"></a>02108                                 }
<a name="l02109"></a>02109                             }
<a name="l02110"></a>02110                             <span class="comment">// sparks</span>
<a name="l02111"></a>02111                             <span class="keywordflow">if</span> (!nodes[i].iswheel &amp;&amp; ns &gt; 1.0 &amp;&amp; !nodes[i].disable_sparks)
<a name="l02112"></a>02112                             {
<a name="l02113"></a>02113                                 <span class="comment">// friction &lt; 10 will remove the &#39;f&#39; nodes from the spark generation nodes</span>
<a name="l02114"></a>02114                                 <span class="keywordflow">if</span> (sparksp) sparksp-&gt;allocSparks(nodes[i].AbsPosition, nodes[i].Velocity);
<a name="l02115"></a>02115                             }
<a name="l02116"></a>02116                             <span class="keywordflow">if</span> (nodes[i].iswheel &amp;&amp; ns &lt; thresold)
<a name="l02117"></a>02117                             {
<a name="l02118"></a>02118                                 <span class="keywordflow">if</span> (useSkidmarks)
<a name="l02119"></a>02119                                 {
<a name="l02120"></a>02120                                     wheels[nodes[i].wheelid].isSkiding = <span class="keyword">false</span>;
<a name="l02121"></a>02121                                 }
<a name="l02122"></a>02122                             }
<a name="l02123"></a>02123                             <span class="keywordflow">break</span>;
<a name="l02124"></a>02124 
<a name="l02125"></a>02125                         <span class="keywordflow">case</span> <a class="code" href="class_collisions.html#abc67d9eaedcf832c061f5925bdae7964ad63920e8d3da864a3421380e5fbe7579">Collisions::FX_CLUMPY</a>:
<a name="l02126"></a>02126                             <span class="keywordflow">if</span> (nodes[i].Velocity.squaredLength() &gt; 1.0)
<a name="l02127"></a>02127                             {
<a name="l02128"></a>02128                                 <span class="keywordflow">if</span> (clumpp) clumpp-&gt;allocClump(nodes[i].AbsPosition, nodes[i].Velocity/2.0, gm-&gt;<a class="code" href="structground__model__t.html#a2e17d0e8ddc90c1fa2c52d7d36f0b1f2">fx_colour</a>);
<a name="l02129"></a>02129                             }
<a name="l02130"></a>02130                             <span class="keywordflow">break</span>;
<a name="l02131"></a>02131                         <span class="keywordflow">default</span>:
<a name="l02132"></a>02132                             <span class="comment">//Useless for the moment</span>
<a name="l02133"></a>02133                             <span class="keywordflow">break</span>;
<a name="l02134"></a>02134                         }
<a name="l02135"></a>02135                     }
<a name="l02136"></a>02136 
<a name="l02137"></a>02137                     wheels[nodes[i].wheelid].lastEventHandler = handlernum;
<a name="l02138"></a>02138 
<a name="l02139"></a>02139                     lastFuzzyGroundModel = gm;
<a name="l02140"></a>02140                 }
<a name="l02141"></a>02141                 nodes[i].collTestTimer = 0.0;
<a name="l02142"></a>02142             }
<a name="l02143"></a>02143         }
<a name="l02144"></a>02144 
<a name="l02145"></a>02145         <span class="comment">// record g forces on cameras</span>
<a name="l02146"></a>02146         <span class="keywordflow">if</span> (i == cameranodepos[0])
<a name="l02147"></a>02147         {
<a name="l02148"></a>02148             cameranodeacc += nodes[i].Forces * nodes[i].inverted_mass;
<a name="l02149"></a>02149             cameranodecount++;
<a name="l02150"></a>02150         }
<a name="l02151"></a>02151 
<a name="l02152"></a>02152         <span class="comment">// integration</span>
<a name="l02153"></a>02153         <span class="keywordflow">if</span> (!nodes[i].locked)
<a name="l02154"></a>02154         {
<a name="l02155"></a>02155             nodes[i].Velocity += nodes[i].Forces * nodes[i].inverted_mass * dt;
<a name="l02156"></a>02156             nodes[i].RelPosition += nodes[i].Velocity * dt;
<a name="l02157"></a>02157             nodes[i].AbsPosition = origin;
<a name="l02158"></a>02158             nodes[i].AbsPosition += nodes[i].RelPosition;
<a name="l02159"></a>02159         }
<a name="l02160"></a>02160 
<a name="l02161"></a>02161         <span class="comment">// prepare next loop (optimisation)</span>
<a name="l02162"></a>02162         <span class="comment">// we start forces from zero</span>
<a name="l02163"></a>02163         <span class="comment">// start with gravity</span>
<a name="l02164"></a>02164         nodes[i].Forces = nodes[i].gravimass;
<a name="l02165"></a>02165 
<a name="l02166"></a>02166         <span class="keywordflow">if</span> (fuseAirfoil)
<a name="l02167"></a>02167         {
<a name="l02168"></a>02168             <span class="comment">// aerodynamics on steroids!</span>
<a name="l02169"></a>02169             nodes[i].Forces += fusedrag;
<a name="l02170"></a>02170         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!disableDrag)
<a name="l02171"></a>02171         {
<a name="l02172"></a>02172             <span class="comment">// add viscous drag (turbulent model)</span>
<a name="l02173"></a>02173             <span class="keywordflow">if</span> ((step&amp;7) &amp;&amp; !increased_accuracy)
<a name="l02174"></a>02174             {
<a name="l02175"></a>02175                 <span class="comment">// fasttrack drag</span>
<a name="l02176"></a>02176                 nodes[i].Forces += nodes[i].lastdrag;
<a name="l02177"></a>02177             } <span class="keywordflow">else</span>
<a name="l02178"></a>02178             {
<a name="l02179"></a>02179                 Real speed = <a class="code" href="_approx_math_8h.html#a490412854eb41c73cdb44120e33cb2f4">approx_sqrt</a>(nodes[i].Velocity.squaredLength()); <span class="comment">//we will (not) reuse this</span>
<a name="l02180"></a>02180                 <span class="comment">// plus: turbulences</span>
<a name="l02181"></a>02181                 Real defdragxspeed = <a class="code" href="_beam_data_8h.html#a152528669cc1695b27198d77a2ace656">DEFAULT_DRAG</a> * speed;
<a name="l02182"></a>02182                 <span class="comment">//Real maxtur=defdragxspeed*speed*0.01f;</span>
<a name="l02183"></a>02183                 nodes[i].lastdrag =- defdragxspeed * nodes[i].Velocity;
<a name="l02184"></a>02184                 Real maxtur = defdragxspeed * speed * 0.005f;
<a name="l02185"></a>02185                 nodes[i].lastdrag += maxtur * <a class="code" href="struct_vector3.html">Vector3</a>(<a class="code" href="_approx_math_8h.html#a935ee6fdb8b4bb87c69a20ca0cc6601f">frand_11</a>(), <a class="code" href="_approx_math_8h.html#a935ee6fdb8b4bb87c69a20ca0cc6601f">frand_11</a>(), <a class="code" href="_approx_math_8h.html#a935ee6fdb8b4bb87c69a20ca0cc6601f">frand_11</a>());
<a name="l02186"></a>02186                 nodes[i].Forces += nodes[i].lastdrag;
<a name="l02187"></a>02187             }
<a name="l02188"></a>02188         }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190         <span class="comment">//if in water</span>
<a name="l02191"></a>02191         <span class="keywordflow">if</span> (water &amp;&amp; water-&gt;<a class="code" href="class_i_water.html#a0d07fdfe2dadf9e7e7ebc9266c0bd4a0">isUnderWater</a>(nodes[i].AbsPosition))
<a name="l02192"></a>02192         {
<a name="l02193"></a>02193             <span class="comment">//basic buoyance</span>
<a name="l02194"></a>02194             watercontact = <span class="keyword">true</span>;
<a name="l02195"></a>02195 
<a name="l02196"></a>02196             <span class="keywordflow">if</span> (free_buoycab == 0)
<a name="l02197"></a>02197             {
<a name="l02198"></a>02198                 <span class="comment">// water drag (turbulent)</span>
<a name="l02199"></a>02199                 Real speed = <a class="code" href="_approx_math_8h.html#a490412854eb41c73cdb44120e33cb2f4">approx_sqrt</a>(nodes[i].Velocity.squaredLength()); <span class="comment">//we will (not) reuse this</span>
<a name="l02200"></a>02200                 nodes[i].Forces -= (<a class="code" href="_beam_data_8h.html#ae6920c288dcae54bc255c1b6ade9ee3b">DEFAULT_WATERDRAG</a> * speed) * nodes[i].Velocity;
<a name="l02201"></a>02201                 nodes[i].Forces += nodes[i].buoyancy * Vector3::UNIT_Y;
<a name="l02202"></a>02202                 <span class="comment">// basic splashing</span>
<a name="l02203"></a>02203                 <span class="keywordflow">if</span> (doUpdate &amp;&amp; water-&gt;<a class="code" href="class_i_water.html#ad2499255884025d55a940eb24ecd8e4d">getHeight</a>() - nodes[i].AbsPosition.y &lt; 0.2 &amp;&amp; nodes[i].Velocity.squaredLength() &gt; 4.0 &amp;&amp; !nodes[i].disable_particles)
<a name="l02204"></a>02204                 {
<a name="l02205"></a>02205                     <span class="keywordflow">if</span> (splashp) splashp-&gt;allocSplash(nodes[i].AbsPosition, nodes[i].Velocity);
<a name="l02206"></a>02206                     <span class="keywordflow">if</span> (ripplep) ripplep-&gt;allocRipple(nodes[i].AbsPosition, nodes[i].Velocity);
<a name="l02207"></a>02207                 }
<a name="l02208"></a>02208             }
<a name="l02209"></a>02209             <span class="comment">// engine stall</span>
<a name="l02210"></a>02210             <span class="keywordflow">if</span> (i == cinecameranodepos[0] &amp;&amp; engine)
<a name="l02211"></a>02211             {
<a name="l02212"></a>02212                 engine-&gt;stop();
<a name="l02213"></a>02213             }
<a name="l02214"></a>02214             <span class="comment">// wetness</span>
<a name="l02215"></a>02215             nodes[i].wetstate = <a class="code" href="_beam_data_8h.html#a7ff5f2dff38e7639981794c43dc9167ba9aa5c6157ab19463e09d1db5039cc082" title="node is wet">WET</a>;
<a name="l02216"></a>02216         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nodes[i].wetstate == <a class="code" href="_beam_data_8h.html#a7ff5f2dff38e7639981794c43dc9167ba9aa5c6157ab19463e09d1db5039cc082" title="node is wet">WET</a>)
<a name="l02217"></a>02217         {
<a name="l02218"></a>02218             nodes[i].wetstate = <a class="code" href="_beam_data_8h.html#a7ff5f2dff38e7639981794c43dc9167baad1e429e37dfbd6d68c8dccf300da474" title="node is dripping">DRIPPING</a>;
<a name="l02219"></a>02219             nodes[i].wettime = 0;
<a name="l02220"></a>02220         }
<a name="l02221"></a>02221     }
<a name="l02222"></a>02222 }
<a name="l02223"></a>02223 
<a name="l02224"></a><a class="code" href="class_beam.html#a18da707a9202850ae927ec9d0fd435b1">02224</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a18da707a9202850ae927ec9d0fd435b1">Beam::forwardCommands</a>()
<a name="l02225"></a>02225 {
<a name="l02226"></a>02226     <a class="code" href="class_beam.html">Beam</a>** trucks = <a class="code" href="class_streamable_factory.html#a233cafcf6f87f5779b1a26a5a48d8f6d">BeamFactory::getSingleton</a>().<a class="code" href="class_beam_factory.html#aa7c42481b46a78459831fa0900ab8d67">getTrucks</a>();
<a name="l02227"></a>02227     <span class="keywordtype">int</span> numtrucks = <a class="code" href="class_streamable_factory.html#a233cafcf6f87f5779b1a26a5a48d8f6d">BeamFactory::getSingleton</a>().<a class="code" href="class_beam_factory.html#a5f3755f8cd44e6972e463cc6aaa9f181">getTruckCount</a>();
<a name="l02228"></a>02228 
<a name="l02229"></a>02229     <span class="comment">// forward things to trailers</span>
<a name="l02230"></a>02230     <span class="keywordflow">if</span> (numtrucks &gt; 1 &amp;&amp; state==<a class="code" href="_beam_data_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a84b328a7ebdea4c8c4ed62e035ada28d" title="leading truck">ACTIVATED</a> &amp;&amp; forwardcommands)
<a name="l02231"></a>02231     {
<a name="l02232"></a>02232         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numtrucks; i++)
<a name="l02233"></a>02233         {
<a name="l02234"></a>02234             <span class="keywordflow">if</span> (!trucks[i]) <span class="keywordflow">continue</span>;
<a name="l02235"></a>02235             <span class="keywordflow">if</span> (trucks[i]-&gt;state==<a class="code" href="_beam_data_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4ad1f631f337198879fbcd59366765574f" title="not leading but active">DESACTIVATED</a> &amp;&amp; trucks[i]-&gt;importcommands)
<a name="l02236"></a>02236             {
<a name="l02237"></a>02237                 <span class="comment">// forward commands</span>
<a name="l02238"></a>02238                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=1; j&lt;=<a class="code" href="_beam_data_8h.html#ab666a57e1a89c01fb894ac44469612ba" title="maximum number of commands per truck">MAX_COMMANDS</a>; j++)
<a name="l02239"></a>02239                 {
<a name="l02240"></a>02240                     trucks[i]-&gt;<a class="code" href="structrig__t.html#a6d8e52606e49c2d1b62feb8b1d2dfb8a">commandkey</a>[j].<a class="code" href="structcommand__t.html#acfc3434f864e7b0884fad026303066b9">playerInputValue</a> = std::max(commandkey[j].playerInputValue, commandkey[j].commandValue);
<a name="l02241"></a>02241                 }
<a name="l02242"></a>02242                 <span class="comment">// just send brake and lights to the connected truck, and no one else :)</span>
<a name="l02243"></a>02243                 <span class="keywordflow">for</span> (std::vector&lt;hook_t&gt;::iterator it=hooks.begin(); it!=hooks.end(); it++)
<a name="l02244"></a>02244                 {
<a name="l02245"></a>02245                     <span class="keywordflow">if</span> (!it-&gt;lockTruck) <span class="keywordflow">continue</span>;
<a name="l02246"></a>02246                     <span class="comment">// forward brake</span>
<a name="l02247"></a>02247                     it-&gt;lockTruck-&gt;brake = brake;
<a name="l02248"></a>02248                     it-&gt;lockTruck-&gt;parkingbrake = parkingbrake;
<a name="l02249"></a>02249 
<a name="l02250"></a>02250                     <span class="comment">// forward lights</span>
<a name="l02251"></a>02251                     it-&gt;lockTruck-&gt;lights = lights;
<a name="l02252"></a>02252                     it-&gt;lockTruck-&gt;blinkingtype = blinkingtype;
<a name="l02253"></a>02253                     <span class="comment">//for (int k=0; k&lt;4; k++)</span>
<a name="l02254"></a>02254                     <span class="comment">//  lockTruck-&gt;setCustomLight(k, getCustomLight(k));</span>
<a name="l02255"></a>02255                     <span class="comment">//forward reverse light e.g. for trailers</span>
<a name="l02256"></a>02256                     it-&gt;lockTruck-&gt;reverselight = getReverseLightVisible();
<a name="l02257"></a>02257                 }
<a name="l02258"></a>02258             }
<a name="l02259"></a>02259         }
<a name="l02260"></a>02260     }
<a name="l02261"></a>02261 }
<a name="l02262"></a>02262 
<a name="l02263"></a><a class="code" href="class_beam.html#a3b31e471f0bffa4478e8636527bea795">02263</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#a3b31e471f0bffa4478e8636527bea795">Beam::calcHooks</a>()
<a name="l02264"></a>02264 {
<a name="l02265"></a>02265     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Hooks);
<a name="l02266"></a>02266     <span class="comment">//locks - this is not active in network mode</span>
<a name="l02267"></a>02267     <span class="keyword">auto</span> hooks_end = hooks.end();
<a name="l02268"></a>02268     <span class="keywordflow">for</span> (<span class="keyword">auto</span> it=hooks.begin(); it != hooks_end; ++it)
<a name="l02269"></a>02269     {
<a name="l02270"></a>02270         <span class="keywordflow">if</span> (it-&gt;lockNode &amp;&amp; it-&gt;locked == <a class="code" href="_beam_data_8h.html#a94798fdadfbf49a7c658ace669a1d310aa27d4c72b06be65e90117df9962a1aad" title="prelocking, attraction forces in action">PRELOCK</a>)
<a name="l02271"></a>02271         {
<a name="l02272"></a>02272             <span class="keywordflow">if</span> (it-&gt;beam-&gt;disabled)
<a name="l02273"></a>02273             {
<a name="l02274"></a>02274                 <span class="comment">//enable beam if not enabled yet between those 2 nodes</span>
<a name="l02275"></a>02275                 it-&gt;beam-&gt;p2       = it-&gt;lockNode;
<a name="l02276"></a>02276                 it-&gt;beam-&gt;p2truck  = it-&gt;lockTruck;
<a name="l02277"></a>02277                 it-&gt;beam-&gt;L = (it-&gt;hookNode-&gt;AbsPosition - it-&gt;lockNode-&gt;AbsPosition).length();
<a name="l02278"></a>02278                 it-&gt;beam-&gt;disabled = <span class="keyword">false</span>;
<a name="l02279"></a>02279                 <span class="keywordflow">if</span> (it-&gt;beam-&gt;mSceneNode-&gt;numAttachedObjects() == 0 &amp;&amp; it-&gt;is_hook_visible)
<a name="l02280"></a>02280                 {
<a name="l02281"></a>02281                     it-&gt;beam-&gt;mSceneNode-&gt;attachObject(it-&gt;beam-&gt;mEntity);
<a name="l02282"></a>02282                 }
<a name="l02283"></a>02283             } <span class="keywordflow">else</span>
<a name="l02284"></a>02284             {
<a name="l02285"></a>02285                 <span class="keywordflow">if</span> (it-&gt;beam-&gt;L &lt; it-&gt;beam-&gt;commandShort)
<a name="l02286"></a>02286                 {
<a name="l02287"></a>02287                     <span class="comment">//shortlimit reached -&gt; status LOCKED</span>
<a name="l02288"></a>02288                     it-&gt;locked = <a class="code" href="_beam_data_8h.html#a94798fdadfbf49a7c658ace669a1d310a6b4af979c9694e48f340397ac08dfd1c" title="lock locked.">LOCKED</a>;
<a name="l02289"></a>02289                 } <span class="keywordflow">else</span>
<a name="l02290"></a>02290                 {
<a name="l02291"></a>02291                     <span class="comment">//shorten the connecting beam slowly to locking minrange</span>
<a name="l02292"></a>02292                     <span class="keywordflow">if</span> (it-&gt;beam-&gt;L &gt; it-&gt;lockspeed &amp;&amp; fabs(it-&gt;beam-&gt;stress) &lt; it-&gt;maxforce)
<a name="l02293"></a>02293                     {
<a name="l02294"></a>02294                         it-&gt;beam-&gt;L = (it-&gt;beam-&gt;L - it-&gt;lockspeed);
<a name="l02295"></a>02295                     } <span class="keywordflow">else</span>
<a name="l02296"></a>02296                     {
<a name="l02297"></a>02297                         <span class="keywordflow">if</span> (fabs(it-&gt;beam-&gt;stress) &lt; it-&gt;maxforce)
<a name="l02298"></a>02298                         {
<a name="l02299"></a>02299                             it-&gt;beam-&gt;L = 0.001f;
<a name="l02300"></a>02300                             <span class="comment">//locking minrange or stress exeeded -&gt; status LOCKED</span>
<a name="l02301"></a>02301                             it-&gt;locked = <a class="code" href="_beam_data_8h.html#a94798fdadfbf49a7c658ace669a1d310a6b4af979c9694e48f340397ac08dfd1c" title="lock locked.">LOCKED</a>;
<a name="l02302"></a>02302                         } <span class="keywordflow">else</span>
<a name="l02303"></a>02303                         {
<a name="l02304"></a>02304                             <span class="keywordflow">if</span> (it-&gt;nodisable)
<a name="l02305"></a>02305                             {
<a name="l02306"></a>02306                                 <span class="comment">//force exceed, but beam is set to nodisable, just lock it in this position</span>
<a name="l02307"></a>02307                                 it-&gt;locked = <a class="code" href="_beam_data_8h.html#a94798fdadfbf49a7c658ace669a1d310a6b4af979c9694e48f340397ac08dfd1c" title="lock locked.">LOCKED</a>;
<a name="l02308"></a>02308                             } <span class="keywordflow">else</span>
<a name="l02309"></a>02309                             {
<a name="l02310"></a>02310                                 <span class="comment">//force exceeded reset the hook node</span>
<a name="l02311"></a>02311                                 it-&gt;beam-&gt;mSceneNode-&gt;detachAllObjects();
<a name="l02312"></a>02312                                 it-&gt;locked = <a class="code" href="_beam_data_8h.html#a94798fdadfbf49a7c658ace669a1d310a4ade5a087dd858a01c36ce7ad8f64e36" title="lock not locked">UNLOCKED</a>;
<a name="l02313"></a>02313                                 <span class="keywordflow">if</span> (it-&gt;lockNode) it-&gt;lockNode-&gt;lockednode=0;
<a name="l02314"></a>02314                                 it-&gt;lockNode       = 0;
<a name="l02315"></a>02315                                 it-&gt;lockTruck      = 0;
<a name="l02316"></a>02316                                 it-&gt;beam-&gt;p2       = &amp;nodes[0];
<a name="l02317"></a>02317                                 it-&gt;beam-&gt;p2truck  = 0;
<a name="l02318"></a>02318                                 it-&gt;beam-&gt;L        = (nodes[0].AbsPosition - it-&gt;hookNode-&gt;AbsPosition).length();
<a name="l02319"></a>02319                                 it-&gt;beam-&gt;disabled = <span class="keyword">true</span>;
<a name="l02320"></a>02320                             }
<a name="l02321"></a>02321                         }
<a name="l02322"></a>02322                     }
<a name="l02323"></a>02323                 }
<a name="l02324"></a>02324             }
<a name="l02325"></a>02325         }
<a name="l02326"></a>02326     }
<a name="l02327"></a>02327     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Hooks);
<a name="l02328"></a>02328 }
<a name="l02329"></a>02329 
<a name="l02330"></a><a class="code" href="class_beam.html#aa7ed0edd3888db29d7d9cfc94f76e42a">02330</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#aa7ed0edd3888db29d7d9cfc94f76e42a">Beam::calcRopes</a>()
<a name="l02331"></a>02331 {
<a name="l02332"></a>02332     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_Ropes);
<a name="l02333"></a>02333     <span class="keywordflow">if</span> (ropes.size())
<a name="l02334"></a>02334     {
<a name="l02335"></a>02335         <span class="keywordflow">for</span> (std::vector &lt;rope_t&gt;::iterator it = ropes.begin(); it!=ropes.end(); it++)
<a name="l02336"></a>02336         {
<a name="l02337"></a>02337             <span class="keywordflow">if</span> (it-&gt;lockedto)
<a name="l02338"></a>02338             {
<a name="l02339"></a>02339                 it-&gt;beam-&gt;p2-&gt;AbsPosition = it-&gt;lockedto-&gt;AbsPosition;
<a name="l02340"></a>02340                 it-&gt;beam-&gt;p2-&gt;RelPosition = it-&gt;lockedto-&gt;AbsPosition - origin; <span class="comment">//ropes[i].lockedtruck-&gt;origin; //we have a problem here</span>
<a name="l02341"></a>02341                 it-&gt;beam-&gt;p2-&gt;Velocity = it-&gt;lockedto-&gt;Velocity;
<a name="l02342"></a>02342                 it-&gt;lockedto-&gt;Forces = it-&gt;lockedto-&gt;Forces + it-&gt;beam-&gt;p2-&gt;Forces;
<a name="l02343"></a>02343                 it-&gt;beam-&gt;p2-&gt;Forces = Vector3::ZERO;
<a name="l02344"></a>02344             }
<a name="l02345"></a>02345         }
<a name="l02346"></a>02346     }
<a name="l02347"></a>02347     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_Ropes);
<a name="l02348"></a>02348 }
<a name="l02349"></a>02349 
<a name="l02350"></a><a class="code" href="class_beam.html#ac9ec9711efca65a823f259ccdd509ae5">02350</a> <span class="keywordtype">void</span> <a class="code" href="class_beam.html#ac9ec9711efca65a823f259ccdd509ae5">Beam::updateSkeletonColouring</a>(<span class="keywordtype">int</span> doUpdate)
<a name="l02351"></a>02351 {
<a name="l02352"></a>02352     <a class="code" href="_beam_stats_8h.html#a391ee1ea29f8141677b946364a7f3ae1">BES_START</a>(BES_CORE_SkeletonColouring);
<a name="l02353"></a>02353     <span class="keywordflow">if</span> ((skeleton &amp;&amp; doUpdate) || replay)
<a name="l02354"></a>02354     {
<a name="l02355"></a>02355         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;free_beam; i++)
<a name="l02356"></a>02356         {
<a name="l02357"></a>02357             <span class="keywordflow">if</span> (!beams[i].disabled)
<a name="l02358"></a>02358             {
<a name="l02359"></a>02359                 <span class="keywordflow">if</span> ((skeleton == 2 || replay) &amp;&amp; !beams[i].broken &amp;&amp; beams[i].mEntity &amp;&amp; beams[i].mSceneNode)
<a name="l02360"></a>02360                 {
<a name="l02361"></a>02361                     <span class="keywordtype">float</span> tmp=beams[i].stress/beams[i].minmaxposnegstress;
<a name="l02362"></a>02362                     <span class="keywordtype">float</span> sqtmp=tmp*tmp;
<a name="l02363"></a>02363                     beams[i].scale = (sqtmp*sqtmp)*100.0f*<a class="code" href="_approx_math_8h.html#ad685178dbcfdd207c7306561512e1582">sign</a>(tmp);
<a name="l02364"></a>02364                 }
<a name="l02365"></a>02365                 <span class="keywordflow">if</span> (skeleton == 1 &amp;&amp; !beams[i].broken &amp;&amp; beams[i].mEntity &amp;&amp; beams[i].mSceneNode)
<a name="l02366"></a>02366                 {
<a name="l02367"></a>02367                     <span class="keywordtype">int</span> scale=(int)beams[i].scale * 100;
<a name="l02368"></a>02368                     <span class="keywordflow">if</span> (scale&gt;100) scale=100;
<a name="l02369"></a>02369                     <span class="keywordflow">if</span> (scale&lt;-100) scale=-100;
<a name="l02370"></a>02370                     <span class="keywordtype">char</span> bname[256];
<a name="l02371"></a>02371                     sprintf(bname, <span class="stringliteral">&quot;mat-beam-%d&quot;</span>, scale);
<a name="l02372"></a>02372                     beams[i].mEntity-&gt;setMaterialName(bname);
<a name="l02373"></a>02373                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (beams[i].mSceneNode &amp;&amp; (beams[i].broken || beams[i].disabled) &amp;&amp; beams[i].mSceneNode)
<a name="l02374"></a>02374                 {
<a name="l02375"></a>02375                     beams[i].mSceneNode-&gt;detachAllObjects();
<a name="l02376"></a>02376                 }
<a name="l02377"></a>02377             }
<a name="l02378"></a>02378         }
<a name="l02379"></a>02379     }
<a name="l02380"></a>02380     <a class="code" href="_beam_stats_8h.html#aaf44ee1aa7b43f90fd87e0d82c94d2e7">BES_STOP</a>(BES_CORE_SkeletonColouring);
<a name="l02381"></a>02381 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 12 2015 11:55:31 for Rigs of Rods by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
